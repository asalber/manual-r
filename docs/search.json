[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Curso básico de análisis de datos con R",
    "section": "",
    "text": "Prefacio"
  },
  {
    "objectID": "index.html#propósito-de-este-manual",
    "href": "index.html#propósito-de-este-manual",
    "title": "Curso básico de análisis de datos con R",
    "section": "Propósito de este manual",
    "text": "Propósito de este manual\nEste manual proporciona una introducción amigable al lenguaje de programación R para aquellas personas interesadas en utilizar este lenguaje para el análisis de datos.\nEl manual empieza con los conceptos básicos del lenguaje de programación R pero enseguida aborda su uso para la visualización y el análisis estadístico de datos, haciendo un recorrido por los test estadísticos más comunes.\nLo más interesante de este manual es la multitud de ejemplos que ilustran el uso de las técnicas estadísticas presentadas, así como los problemas propuestos.\nEl manual no aborda los fundamentos matemáticos de los análisis estadísticos presentados, aunque si explica brevemente cuándo deben usarse y cuándo no, así como las interpretaciones de los resultados obtenidos en los ejemplos. Si alguien está interesado en profundizar en los detalles matemáticos, puede visitar esta página.\nNo es un curso de programación en R, sino de uso de sus funciones predefinidas y de los paquetes más habituales para el análisis de datos.\nPara cualquier comentario o sugerencia sobre este manual escriba al autor (asalber@ceu.es)."
  },
  {
    "objectID": "index.html#licencia",
    "href": "index.html#licencia",
    "title": "Curso básico de análisis de datos con R",
    "section": "Licencia",
    "text": "Licencia\nEsta obra está bajo una licencia Reconocimiento – No comercial – Compartir bajo la misma licencia 3.0 España de Creative Commons. Para ver una copia de esta licencia, visite https://creativecommons.org/licenses/by-nc-sa/3.0/es/.\nCon esta licencia eres libre de:\n\nCopiar, distribuir y mostrar este trabajo.\nRealizar modificaciones de este trabajo.\n\nBajo las siguientes condiciones:\n\nReconocimiento. Debe reconocer los créditos de la obra de la manera especificada por el autor o el licenciador (pero no de una manera que sugiera que tiene su apoyo o apoyan el uso que hace de su obra).\nNo comercial. No puede utilizar esta obra para fines comerciales.\nCompartir bajo la misma licencia. Si altera o transforma esta obra, o genera una obra derivada, sólo puede distribuir la obra generada bajo una licencia idéntica a ésta.\n\nAl reutilizar o distribuir la obra, tiene que dejar bien claro los términos de la licencia de esta obra.\nEstas condiciones pueden no aplicarse si se obtiene el permiso del titular de los derechos de autor.\nNada en esta licencia menoscaba o restringe los derechos morales del autor."
  },
  {
    "objectID": "01-intro.html#instalación-de-r",
    "href": "01-intro.html#instalación-de-r",
    "title": "1  Introducción a R",
    "section": "1.1 Instalación de R",
    "text": "1.1 Instalación de R\nR puede descargarse desde el sitio web oficial de R o desde el repositorio principal de paquetes de R CRAN. Basta con descargar el archivo de instalación correspondiente al sistema operativo de nuestro ordenador y realizar la instalación como cualquier otro programa.\nEl intérprete de R se arranca desde la terminal, aunque en Windows incorpora su propia aplicación, pero es muy básica. En general, para trabajos serios, conviene utilizar un entorno de desarrollo para R."
  },
  {
    "objectID": "01-intro.html#entornos-de-desarrollo",
    "href": "01-intro.html#entornos-de-desarrollo",
    "title": "1  Introducción a R",
    "section": "1.2 Entornos de desarrollo",
    "text": "1.2 Entornos de desarrollo\nPor defecto el entorno de trabajo de R es en línea de comandos, lo que significa que los cálculos y los análisis se realizan mediante comandos o instrucciones que el usuario teclea en una ventana de texto. No obstante, existen distintas interfaces gráficas de usuario que facilitan su uso, sobre todo para usuarios noveles. Algunas de ellas, como las que se enumeran a continuación, son completos entornos de desarrollo que facilitan la gestión de cualquier proyecto:\n\nRStudio. Probablemente el entorno de desarrollo más extendido para programar con R ya que incorpora multitud de utilidades para facilitar la programación con R.\nRKWard. Es otra otro de los entornos de desarrollo más completos que además incluye a posibilidad de añadir nuevos menús y cuadros de diálogo personalizados.\nVisual Studio Code. Es un entorno de desarrollo de propósito general ampliamente extendido. Aunque no es un entorno de desarrollo específico para R, incluye una extensión con utilidades que facilitan mucho el desarrollo con R."
  },
  {
    "objectID": "02-tipos-datos-simples.html#conversión-de-tipos",
    "href": "02-tipos-datos-simples.html#conversión-de-tipos",
    "title": "2  Tipos de datos simples",
    "section": "2.1 Conversión de tipos",
    "text": "2.1 Conversión de tipos\nEn muchas ocasiones es posible convertir un dato de un tipo a otro distinto. Para ello se usan las siguientes funciones:\n\nas.numeric(x): Convierte el dato de x al tipo numeric siempre que sea posible o tenga sentido la conversión. Para convertir una cadena en un número, la cadena tiene que representar un número. El valor lógico TRUE se convierte en 1 y el FALSE en 0.\nas.integer(x): Convierte el dato de x al tipo integer siempre que sea posible o tenga sentido la conversión. Para convertir una cadena en un número entero, la cadena tiene que representar un número entero. El valor lógico TRUE se convierte en 1 y el FALSE en 0.\nas.character(x): Convierte el tipo de dato de x al tipo character simplemente añadiendo comillas.\nas.logical(x): Convierte el tipo de dato de x al tipo lógico. Para datos numéricos, el 0 se convierte en FALSE y cualquier otro número en TRUE. Para cadenas se obtiene NA excepto para las cadenas \"TRUE\" y \"true\" que se convierten a TRUE y las cadenas \"FALSE\" y \"false\" que se convierten a FALSE.\n\nEl tipo NA no se puede convertir a ningún otro tipo pues representa la ausencia del dato. Lo mismo ocurre con NULL."
  },
  {
    "objectID": "02-tipos-datos-simples.html#operaciones-con-números",
    "href": "02-tipos-datos-simples.html#operaciones-con-números",
    "title": "2  Tipos de datos simples",
    "section": "2.2 Operaciones con números",
    "text": "2.2 Operaciones con números\n\n2.2.1 Operadores aritméticos\nLos siguientes operadores permiten realizar las clásicas operaciones aritméticas entre datos numéricos:\n\nx + y: Devuelve la suma de x e y.\nx - y: Devuelve la resta de x e y.\nx * y: Devuelve el producto de x e y.\nx / y: Devuelve el cociente de x e y.\n\nx %% y: Devuelve el resto de la división entera de x e y.\n\nx ^ y: Devuelve la potencia x elevado a y.\n\n\nEjemplo 2.3  \n\n2 + 3\n\n[1] 5\n\n5 * -2\n\n[1] -10\n\n5 / 2\n\n[1] 2.5\n\n1 / 0\n\n[1] Inf\n\n5 %% 2\n\n[1] 1\n\n2 ^ 3\n\n[1] 8\n\n\n\n\n\n2.2.2 Operadores relacionales\nComparan dos números y devuelven un valor lógico.\n\nx == y: Devuelve TRUE si el número x es igual que el número y, y FALSE en caso contrario.\nx &gt; y: Devuelve TRUE si el número x es mayor que el número y, y FALSE en caso contrario.\nx &lt; y: Devuelve TRUE si el número x es menor que el número y, y FALSE en caso contrario.\nx &gt;= y: Devuelve TRUE si el número x es mayor o igual que el número y, y FALSE en caso contrario.\nx &lt;= y: Devuelve TRUE si el número x es menor o igual a que el número y, y FALSE en caso contrario.\nx != y: Devuelve TRUE si el número x es distinto del número y, y FALSE en caso contrario.\n\n\nEjemplo 2.4  \n\n3 == 3\n\n[1] TRUE\n\n3.1 &lt;= 3\n\n[1] FALSE\n\n4 &gt; 3\n\n[1] TRUE\n\n-1 != 1\n\n[1] TRUE\n\n5 %% 2\n\n[1] 1\n\n2 ^ 3\n\n[1] 8\n\n(2 + 3) ^ 2\n\n[1] 25\n\n\n\n\n\n2.2.3 Funciones y constantes numéricas\nLas siguientes constantes y funciones matemáticas también están ya predefinidas.\n\npi: Devuelve el número \\(\\pi\\).\nsqrt(x): Devuelve la raíz cuadrada de x.\nabs(x): Devuelve el valor absoluto de x.\nround(x, n): Devuelve el redondeo de x a n decimales.\nexp(x): Devuelve la exponencial de x (\\(e^x\\)).\nlog(x): Devuelve el logaritmo neperiano de x.\nsin(x): Devuelve el seno del ángulo x en radianes.\ncos(x): Devuelve el coseno del ángulo x en radianes.\ntan(x): Devuelve la tangente del ángulo x en radianes.\nasin(x): Devuelve el arcoseno de x.\nacos(x): Devuelve el arcocoseno de x.\natan(x): Devuelve el arcotangente de x.\n\n\n\nEjemplo 2.5  \n\nsqrt(9)\n\n[1] 3\n\nabs(-1)\n\n[1] 1\n\nround(1.7)\n\n[1] 2\n\nexp(1)\n\n[1] 2.718282\n\nlog(exp(1))\n\n[1] 1\n\ncos(pi)\n\n[1] -1\n\nasin(1)\n\n[1] 1.570796"
  },
  {
    "objectID": "02-tipos-datos-simples.html#operaciones-con-cadenas",
    "href": "02-tipos-datos-simples.html#operaciones-con-cadenas",
    "title": "2  Tipos de datos simples",
    "section": "2.3 Operaciones con cadenas",
    "text": "2.3 Operaciones con cadenas\n\n2.3.1 Funciones de cadenas\nExisten muchas funciones para cadenas de texto pero las más comunes son:\n\nnchar(c): Devuelve el número de caracteres de la cadena.\npaste(x, y, ..., sep=s): Concatena las cadenas x, y, etc. separándolas por la cadena s. Por defecto la cadena de separación es un espacio en blanco.\nsubstr(c, start=i, stop=j): Devuelve la subcadena de la cadena c desde la posición i hasta la posición j. El primer carácter de una cadena ocupa la posición 1.\ntolower(c): Devuelve la cadena que resulta de convertir la cadena c a minúsculas.\ntoupper(c): Devuelve la cadena que resulta de convertir la cadena c a mayúsculas.\n\n\nEjemplo 2.6  \n\nnchar(\"Me gusta R\")\n\n[1] 10\n\npaste(\"Me\", \"gusta\", \"R\")\n\n[1] \"Me gusta R\"\n\npaste(\"Me\", \"gusta\", \"R\", sep = \"-\")\n\n[1] \"Me-gusta-R\"\n\npaste(\"Me\", \"gusta\", \"R\", sep = \"\")\n\n[1] \"MegustaR\"\n\nsubstr(\"Me gusta R\", 4, 8)\n\n[1] \"gusta\"\n\ntolower(\"Me gusta R\")\n\n[1] \"me gusta r\"\n\ntoupper(\"Me gusta R\")\n\n[1] \"ME GUSTA R\"\n\n\n\n\n\n2.3.2 Operaciones de comparación de cadenas\n\nx == y : Devuelve TRUE si la cadena x es igual que la cadena y, y FALSE en caso contrario.\nx &gt; y : Devuelve TRUE si la cadena x sucede a la cadena y, y FALSE en caso contrario.\nx &lt; y : Devuelve TRUE si la cadena x antecede a la cadena y, y FALSE en caso contrario.\nx &gt;= y : Devuelve TRUE si la cadena x sucede o es igual a la cadena y, y FALSE en caso contrario.\nx &lt;= y : Devuelve TRUE si la cadena x antecede o es igual a la cadena y, y FALSE en caso contrario.\nx != y : Devuelve TRUE si la cadena x es distinta de la cadena y, y FALSE en caso contrario.\n\n Utilizan el orden alfabético, las minúsculas van antes que las mayúsculas, y los números antes que las letras.\n\nEjemplo 2.7  \n\n\"R\" == \"R\"\n\n[1] TRUE\n\n\"R\" == \"r\"\n\n[1] FALSE\n\n\"uno\" &lt; \"dos\"\n\n[1] FALSE\n\n\"A\" &gt; \"a\"\n\n[1] TRUE\n\n\"\" &lt; \"R\"\n\n[1] TRUE"
  },
  {
    "objectID": "02-tipos-datos-simples.html#operaciones-con-datos-lógicos-o-booleanos",
    "href": "02-tipos-datos-simples.html#operaciones-con-datos-lógicos-o-booleanos",
    "title": "2  Tipos de datos simples",
    "section": "2.4 Operaciones con datos lógicos o booleanos",
    "text": "2.4 Operaciones con datos lógicos o booleanos\n\n2.4.1 Operadores lógicos\nA la hora de comparar valores lógicos R asocia a TRUE el valor 1 y a FALSE el valor 0.\n\nx == y: Devuelve TRUE si los booleanos x y y son iguales, y FALSE en caso contrario.\nx &lt; y: Devuelve TRUE si el booleano x es menor que el booleano y, y FALSE en caso contrario.\nx &lt;= y: Devuelve TRUE si el booleano x es menor o igual que el booleano y, y FALSE en caso contrario.\nx &gt; y: Devuelve TRUE si el booleano x es mayor que el booleano y, y FALSE en caso contrario.\nx &gt;= y: Devuelve TRUE si el booleano x es mayor o igual que el booleano y, y FALSE en caso contrario.\nx != y: Devuelve TRUE si el booleano x es distinto que el booleano y, y FALSE en caso contrario.\nNegación !b: Devuelve TRUE si el booleano b es FALSE, y FALSE si es TRUE.\nConjunción x & y: Devuelve TRUE si los booleanos x, y y son TRUE y FALSE en caso contrario.\nDisyunción x | y: Devuelve TRUE si alguno de los booleanos x o y son TRUE, y FALSE en caso contrario.\n\n\nTabla de verdad\n\n\n\nx\ny\n!x\nx & y\nx | y\n\n\n\n\nFALSE\nFALSE\nTRUE\nFALSE\nFALSE\n\n\nFALSE\nTRUE\nTRUE\nFALSE\nTRUE\n\n\nTRUE\nFALSE\nFALSE\nFALSE\nTRUE\n\n\nTRUE\nTRUE\nFALSE\nTRUE\nTRUE\n\n\n\n\nEjemplo 2.8  \n\n!TRUE\n\n[1] FALSE\n\nFALSE | TRUE\n\n[1] TRUE\n\nFALSE | FALSE\n\n[1] FALSE\n\nTRUE & FALSE\n\n[1] FALSE\n\nTRUE & TRUE\n\n[1] TRUE"
  },
  {
    "objectID": "02-tipos-datos-simples.html#variables",
    "href": "02-tipos-datos-simples.html#variables",
    "title": "2  Tipos de datos simples",
    "section": "2.5 Variables",
    "text": "2.5 Variables\nUna variable es un identificador ligado a un valor.\n\n\n\n\n\n\nReglas para nombrar variables\n\n\n\n\nComienzan siempre por una letra o punto, seguida de otras letras, números, puntos o guiones bajos. Si empieza por punto no puede seguirle un número.\nNo se pueden utilizarse palabras reservadas del lenguaje.\n\n\n\nA diferencia de otros lenguajes de programación, las variables no tienen asociado un tipo de dato y no es necesario declararlas antes de usarlas (tipado dinámico).\nPara asignar un valor a una variable se utiliza el operador de asignación &lt;-:\n\nx &lt;- y: Asigna el valor y a la variable x.\n\nAunque es menos común también se puede utilizar el operador =.\nSe puede crear una variable sin ningún valor asociado asignándole el valor NULL.\nUna vez definida una variable, puede utilizarse en cualquier expresión donde tenga sentido el valor que tiene asociado.\nSi una variable ya no va a usarse, es posible eliminarla y liberar el espacio que ocupan sus datos asociados con la siguiente función:\n\nrm(x): Elimina la variable x.\n\n\nEjemplo 2.9  \n\nx &lt;- 3\nx\n\n[1] 3\n\ny &lt;- x + 2\ny\n\n[1] 5\n\n# Valor no definido\nx &lt;- NULL\nx\n\nNULL\n\n# Eliminar y\nrm(y)\n# A partir de aquí, una llamada a y produce un error.\n\n\n\n2.5.1 Prioridad de los operadores\nAl evaluar una expresiones R utiliza el siguiente orden de prioridad de evaluación:\n\n\n\n1\nFunciones predefinidas\n\n\n2\nPotencias (^)\n\n\n3\nProductos y cocientes (*, /, %%)\n\n\n4\nSumas y restas (+, -)\n\n\n5\nOperadores relacionales (==, &gt;, &lt;, &gt;=, &lt;=, !=)\n\n\n6\nNegación (!)\n\n\n7\nConjunción (&)\n\n\n8\nDisyunción (|)\n\n\n9\nAsignación (&lt;-)\n\n\n\nSe puede saltar el orden de evaluación utilizando paréntesis ( ).\n\nEjemplo 2.10  \n\n4 + 8 / 2 ^ 2\n\n[1] 6\n\n4 + (8 / 2) ^ 2\n\n[1] 20\n\n(4 + 8) / 2 ^ 2\n\n[1] 3\n\n(4 + 8 / 2) ^ 2\n\n[1] 64\n\nx &lt;- 2 \ny &lt;- 3\nz &lt;- ! x + 1 &gt; y & y * 2  &lt; x ^ 3\nz\n\n[1] TRUE"
  },
  {
    "objectID": "02-tipos-datos-simples.html#ejercicios",
    "href": "02-tipos-datos-simples.html#ejercicios",
    "title": "2  Tipos de datos simples",
    "section": "2.6 Ejercicios",
    "text": "2.6 Ejercicios\n\nEjercicio 2.1 Se dispone de los siguientes datos de una persona:\n\n\n\nVariable\nValor\n\n\n\n\nedad\n20\n\n\nestatura\n165\n\n\npeso\n60\n\n\nsexo\nmujer\n\n\n\n\nDeclarar las variables anteriores y asignarles los valores correspondientes.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\n# Declaración de variables\nedad &lt;- 20\nestatura &lt;- 165\npeso &lt;- 60\nsexo &lt;- \"mujer\"\n\n\n\n\nDefinir la variable numérica imc con el índice de masa corporal aplicando la siguiente fórmula a las variables anteriores:\n\\[\n\\mbox{imc} = \\frac{\\mbox{peso (kg)}}{\\mbox{estatura (m)}^2}\n\\]\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\n# Cálculo del índice de masa corporal\nimc &lt;- peso / (estatura / 100) ^ 2\nimc\n\n[1] 22.03857\n\n\n\n\n\nMostrar por pantalla el indice de masa corporal calculado en el apartado anterior redondeado a dos decimales y con sus unidades en mayúsculas.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\n# Salida por pantalla\npaste(\"Índice de masa corporal: \", round(imc,2), toupper(\"KG/M²\"))\n\n[1] \"Índice de masa corporal:  22.04 KG/M²\"\n\n\n\n\n\nDefinir la variable booleana obesa con el valor correspondiente a la siguiente condición: ser mujer y no tener una edad superior a 60 y tener un índice de masa corporal mayor o igual que 30. ¿Es esta persona obesa?\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\n# Cálculo de la obesidad\nobesa &lt;- sexo == \"mujer\" & ! edad &gt; 60 & imc &gt;= 30\nobesa\n\n[1] FALSE"
  },
  {
    "objectID": "03-tipos-datos-estructurados.html#vectores",
    "href": "03-tipos-datos-estructurados.html#vectores",
    "title": "3  Tipos de datos estructurados",
    "section": "3.1 Vectores",
    "text": "3.1 Vectores\nEl vector es el tipo de dato estructurado más básicos en R. Un vector es una colección ordenada de elementos del mismo tipo.\n\n3.1.1 Creación de vectores\nPara construir un vector se utiliza la función de combinación c():\n\nc(x1, x2, ...): Devuelve el vector formado por los elementos x1, x2, etc.\n\nTambién es posible utilizar el operador : para generar un vector de números enteros consecutivos:\n\nx:y: Devuelve el vector de números enteros consecutivos desde x hasta y.\n\n\nEjemplo 3.1  \n\nc(1, 2, 3)\n\n[1] 1 2 3\n\nc(\"uno\", \"dos\", \"tres\")\n\n[1] \"uno\"  \"dos\"  \"tres\"\n\n# Vector vacío\nc()\n\nNULL\n\n# Vector con elementos perdidos\nc(1, NA, 3)\n\n[1]  1 NA  3\n\n# Vector de números enteros consecutivos del 2 al 6\n2:6\n\n[1] 2 3 4 5 6\n\n\n\n\n3.1.1.1 Vectores con nombres\nEs posible asignar un nombre a cada elemento de un vector. Los nombres son etiquetas de texto que se asocian a cada elemento. Para asociar un nombre a un elemento se utiliza la sintaxis nombre = valor, donde nombre es una cadena de caracteres y valor es el elemento del vector.\n\nEjemplo 3.2  \n\nc(\"Matemáticas\" = 8.2, \"Física\" = 6.5, \"Economía\" = 4.5)\n\nMatemáticas      Física    Economía \n        8.2         6.5         4.5 \n\n\n\nPara acceder a los nombres de un vector se utiliza la siguiente función:\n\nnames(x): Devuelve un vector de cadenas de caracteres con los nombres de los elementos del vector x.\n\n\nEjemplo 3.3  \n\nnotas &lt;- c(\"Matemáticas\" = 8.2, \"Física\" = 6.5, \"Economía\" = 4.5)\nnames(notas)\n\n[1] \"Matemáticas\" \"Física\"      \"Economía\"   \n\n\n\n\n\n\n3.1.2 Tamaño de un vector\nEl número de elementos de un vector es su tamaño y puede averiguarse con la siguiente función.\n\nlenght(x): Devuelve el número de elementos del vector x.\n\n\nEjemplo 3.4  \n\nlength(c(1, 2, 3))\n\n[1] 3\n\nlength(c())\n\n[1] 0\n\n\n\n\n\n3.1.3 Coerción de elementos\nPuesto que los elementos de un vector tienen que ser del mismo tipo, cuando se crea un vector con datos de distintos tipos, la función c() los convertirá al mismo tipo, lo que se conoce como coerción de tipos. La coerción se produce de los tipos menos flexibles a los más flexibles: logical &lt; integer &lt; double &lt; character.\n\nEjemplo 3.5  \n\nc(1, 2.5)\n\n[1] 1.0 2.5\n\nc(FALSE, TRUE, 2)\n\n[1] 0 1 2\n\nc(FALSE, TRUE, 2, \"tres\")\n\n[1] \"FALSE\" \"TRUE\"  \"2\"     \"tres\" \n\n\n\n\n\n3.1.4 Acceso a los elementos de un vector\nPara acceder a los elementos de un vector se utiliza un índice. Como veremos a continuación, este índice puede ser entero, lógico o de cadena de caracteres y se indica siempre entre corchetes [ ] a continuación del vector.\n\n3.1.4.1 Acceso mediante un índice entero\nLos elementos de un vector están ordenados y el acceso más simple a ellos es mediante su número de orden, es decir, indicando entre corchetes [ ] el entero que corresponde a su número de orden. Se puede acceder simultáneamente a varios elementos mediante un vector con sus números de orden.\n\n\n\n\n\n\nAdvertencia\n\n\n\nEn R los índices enteros para acceder a los elementos de un vector comienzan en 1, a diferencia de otros lenguajes de programación que empiezan en 0.\n\n\n\nEjemplo 3.6  \n\nx &lt;- c(2,4,6,8,10)\n# Acceso al elemento que está en la tercera posición\nx[3]\n\n[1] 6\n\n# Acceso a los elementos de las posiciones 2 y 4\nx[c(2, 4)]\n\n[1] 4 8\n\n# Acceso a los elementos de la posición 2 a la 4\nx[2:4]\n\n[1] 4 6 8\n\n# Acceso a todos los elementos excepto el primero y el cuarto\nx[c(-1, -4)]\n\n[1]  4  6 10\n\n\n\n\n\n3.1.4.2 Acceso mediante un índice lógico\nCuando se utiliza un índice lógico, se obtienen los elementos correspondientes a las posiciones donde está el valor booleano TRUE.\n\nEjemplo 3.7  \n\nx &lt;- c(2,4,6,8,10)\n# Acceso al elemento que está en la tercera posición\nx[c(F,F,T,F,F)]\n\n[1] 6\n\n# Acceso a los elementos de las posiciones 2 y 4\nx[c(F,T,F,T,F)]\n\n[1] 4 8\n\n\n\nEsta forma de acceder es útil cuando se genera el vector de índices mediante operadores relacionales. Cuando se aplica un operador relacional a un vector se obtiene otro vector lógico que resulta de aplicar el operador relacional a cada uno de los elementos del vector. De esta manera se puede realizar filtros para obtener los elementos de un vector que cumplen una determinada condición.\n\nEjemplo 3.8  \n\nx &lt;- 1:6\nx %% 2 == 0\n\n[1] FALSE  TRUE FALSE  TRUE FALSE  TRUE\n\n# Filtrado de los valores pares\nx[x %% 2 == 0]\n\n[1] 2 4 6\n\n# Filtrado de los valores pares menores que 5\nx[x %% 2 == 0 & x &lt; 5]\n\n[1] 2 4\n\n\n\n\n\n3.1.4.3 Acceso mediante un índice de cadena\nSi los elementos de un vector tienen nombre, es posible acceder a ellos usando sus nombres como índices.\n\nEjemplo 3.9  \n\nnotas &lt;- c(\"Matemáticas\" = 8.2, \"Física\" = 6.5, \"Economía\" = 4.5)\nnotas[\"Física\"]\n\nFísica \n   6.5 \n\nnotas[c(\"Matemáticas\", \"Economía\")]\n\nMatemáticas    Economía \n        8.2         4.5 \n\n\n\n\n\n\n3.1.5 Pertenencia a un vector\nPara comprobar si un valor en particular es un elemento de un vector se puede utilizar el operador %in%:\n\nx %in% y: Devuelve el booleano TRUE si x es un elemento del vector y, y FALSE en caso contrario.\n\n\nEjemplo 3.10  \n\nx &lt;- 1:3\n2 %in% x\n\n[1] TRUE\n\n4 %in% x\n\n[1] FALSE\n\n\n\n\n\n3.1.6 Modificación de los elementos de un vector\nPara modificar uno o varios elementos de un vector basta con acceder a esos elementos y usar el operador de asignación para asignar nuevos valores.\n\nv[i] &lt;- x: Asigna el dato x a la posición i del vector v.\nv[c(i,j,...)] &lt;- x: Asigna el dato x a las posiciones i, j, etc. del vector v.\n\n\nEjemplo 3.11  \n\nx &lt;- c(1, 2, 3)\nx[2] &lt;- 0\nx\n\n[1] 1 0 3\n\nx[c(1, 3)] &lt;- 1\nx\n\n[1] 1 0 1\n\n\n\n\n\n3.1.7 Añadir elementos a un vector\nPara añadir nuevos elementos a un vector pueden usarse las siguientes funciones:\n\nc(x, y): Devuelve el vector que resulta de añadir al vector x los elementos del vector y.\nappend(x, y, pos): Devuelve el vector que resulta de añadir al vector x los elementos del vector y, a continuación de la posición pos. El parámetro pos es opcional y si no se indica, los elementos de y se añaden al final de los de x.\n\n\nEjemplo 3.12  \n\nx &lt;- c(1, 2, 3)\nc(x, c(4, 5))\n\n[1] 1 2 3 4 5\n\nappend(x, c(4, 5), 2)\n\n[1] 1 2 4 5 3\n\n\n\n\n\n3.1.8 Eliminar elementos de un vector\nPara eliminar los elementos que ocupan una determinada posición se utiliza el operador de acceso, es decir, los corchetes [ ] pero con los índices correspondientes a las posiciones a eliminar, en negativo.\n\nEjemplo 3.13  \n\nx &lt;- c(\"a\", \"b\", \"c\", \"d\", \"e\")\nx[-3]\n\n[1] \"a\" \"b\" \"d\" \"e\"\n\nx[-c(2,4)]\n\n[1] \"a\" \"c\" \"e\"\n\n\n\n\n\n3.1.9 Eliminación de un vector\nPara eliminar los elementos de un vector basta con asignar NULL a la variable que lo contiene, pero si se quiere liberar la memoria que ocupa la variable se utiliza la función rm().\n\n\n3.1.10 Operaciones aritméticas con vectores\n\n3.1.10.1 Operaciones aritméticas elemento a elemento\nPara vectores numéricos las operaciones aritméticas habituales se aplican elemento a elemento. Si los vectores tienen distinto tamaño, el tamaño del vector más pequeño se equipara al tamaño del mayor, reutilizando sus elementos, empezando por el primero.\n\nEjemplo 3.14  \n\nx &lt;- c(1, 2, 3)\ny &lt;- c(0, 1, -1)\nx + y\n\n[1] 1 3 2\n\nx * y\n\n[1]  0  2 -3\n\nx / y\n\n[1] Inf   2  -3\n\nx ^ y\n\n[1] 1.0000000 2.0000000 0.3333333\n\n\n\n\n\n3.1.10.2 Producto escalar de vectores\nPara calcular el producto escalar de dos vectores numéricos se utiliza el operador %*%. Si los vectores tienen distinto tamaño se produce un error.\n\nEjemplo 3.15  \n\nx &lt;- c(1, 2, 3)\ny &lt;- c(0, 1, -1)\nx %*% y\n\n     [,1]\n[1,]   -1"
  },
  {
    "objectID": "03-tipos-datos-estructurados.html#factores",
    "href": "03-tipos-datos-estructurados.html#factores",
    "title": "3  Tipos de datos estructurados",
    "section": "3.2 Factores",
    "text": "3.2 Factores\n\n3.2.1 Operaciones con factores\nUn factor es una estructura de datos especial que se utiliza para representar categorías de variables cualitativas y por tanto puede tomar un conjunto finito de valores predefinidos conocido como niveles del factor.\nPara definir un factor se utiliza la siguiente función:\n\nfactor(x, levels = niveles): Crea un dato de tipo factor con los elementos del vector x. Los niveles del factor pueden indicarse mediante el parámetro levels, pasándole un vector con los valores posibles. Si no se indica el parámetro levels los niveles del factor se obtienen automáticamente a partir de los elementos del vector x (tantos niveles con valores distintos tenga).\n\nLos factores son en realidad vectores de números enteros a los que se le añade un atributo especial para indicar los niveles del factor.\n\nEjemplo 3.16  \n\nsexo &lt;- factor(c(\"mujer\", \"hombre\", \"mujer\"))\nsexo\n\n[1] mujer  hombre mujer \nLevels: hombre mujer\n\nclass(sexo)\n\n[1] \"factor\"\n\nstr(sexo)\n\n Factor w/ 2 levels \"hombre\",\"mujer\": 2 1 2\n\ngrupo.sanguineo &lt;- factor(c(\"B\", \"A\", \"A\"), levels = c(\"A\", \"B\", \"AB\", \"0\"), )\ngrupo.sanguineo\n\n[1] B A A\nLevels: A B AB 0\n\n\n\nEs posible establecer un orden entre los niveles de un factor añadiendo el parámetro ordered = TRUE a la función anterior. Esto es útil para representar categorías ordinales entre las que existe un orden natural.\n\nEjemplo 3.17  \n\nnivel.estudio &lt;- factor(c(\"Secundarios\", \"Graduado\", \"Bachiller\"), levels = c(\"Sin estudios\", \"Primarios\", \"Secundarios\", \"Bachiller\", \"Graduado\"), ordered = TRUE)\nnivel.estudio\n\n[1] Secundarios Graduado    Bachiller  \nLevels: Sin estudios &lt; Primarios &lt; Secundarios &lt; Bachiller &lt; Graduado\n\n\n\nPara comprobar si una estructura es del tipo factor se utiliza la siguiente función:\n\nis.factor(x): Devuelve el booleano TRUE si x es del tipo factor, y FALSE en caso contrario.\n\n\n\n3.2.2 Acceso a los elementos de un factor\nSe puede acceder a los elementos de un factor de la misma manera que se accede a los elementos de un vector. Y para obtener sus niveles se utiliza la siguiente función:\n\nlevels(x): Devuelve un vector con los niveles del factor x.\n\n\nEjemplo 3.18  \n\nsexo &lt;- factor(c(\"mujer\", \"hombre\", \"mujer\"))\nsexo[2]\n\n[1] hombre\nLevels: hombre mujer\n\nsexo[c(1, 2)]\n\n[1] mujer  hombre\nLevels: hombre mujer\n\nsexo[-2]\n\n[1] mujer mujer\nLevels: hombre mujer\n\nlevels(sexo)\n\n[1] \"hombre\" \"mujer\" \n\n\n\n\n\n3.2.3 Modificación de los elementos de un factor\nSe puede modificar los elementos de un factor de manera similar a como se modifican los elementos de un vector, es decir accediendo al elemento que se quiere modificar y asignándole un nuevo valor. La única diferencia con los vectores es que si el nuevo valor que se quiere asignar no está entre los niveles del factor, se obtiene el valor NA.\n\nEjemplo 3.19 A continuación se muestran varios de modificación de los elementos de un factor.\n\ngrupo.sanguineo &lt;- factor(c(\"B\", \"A\", \"A\"), levels = c(\"A\", \"B\", \"AB\", \"0\"))\ngrupo.sanguineo\n\n[1] B A A\nLevels: A B AB 0\n\ngrupo.sanguineo[2] &lt;- \"AB\"\ngrupo.sanguineo\n\n[1] B  AB A \nLevels: A B AB 0\n\ngrupo.sanguineo[1] &lt;- \"C\"\n\nWarning in `[&lt;-.factor`(`*tmp*`, 1, value = \"C\"): invalid factor level, NA\ngenerated\n\ngrupo.sanguineo\n\n[1] &lt;NA&gt; AB   A   \nLevels: A B AB 0\n\n\n\nObsérvese en el ejemplo anterior que cuando se intenta asignar un valor a un factor que no está entre sus niveles, se produce un error."
  },
  {
    "objectID": "03-tipos-datos-estructurados.html#listas",
    "href": "03-tipos-datos-estructurados.html#listas",
    "title": "3  Tipos de datos estructurados",
    "section": "3.3 Listas",
    "text": "3.3 Listas\nLas listas son colecciones ordenadas de elementos que pueden ser de distintos tipos. Los elementos de una lista también pueden ser de tipos estructurados (vectores o listas), lo que las convierte en el tipo de dato más versátil de R. Como veremos más adelante, otras estructuras de datos como los data frames o los propios modelos estadísticos se construyen usando listas.\n\n3.3.1 Creación de listas\nPara construir una lista se utiliza la función list():\n\nlist(x1, x2, ...): Devuelve la lista con los elementos x1, x2, etc.\n\n\nEjemplo 3.20  \n\nlist(1, \"dos\", TRUE)\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"dos\"\n\n[[3]]\n[1] TRUE\n\n# Lista con vectores y listas\nx &lt;- list(1, c(\"dos\", \"tres\"), list(4, \"cinco\"))\nx\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] \"dos\"  \"tres\"\n\n[[3]]\n[[3]][[1]]\n[1] 4\n\n[[3]][[2]]\n[1] \"cinco\"\n\nstr(x)\n\nList of 3\n $ : num 1\n $ : chr [1:2] \"dos\" \"tres\"\n $ :List of 2\n  ..$ : num 4\n  ..$ : chr \"cinco\"\n\n# Lista vacía\nlist()\n\nlist()\n\n\n\n\n3.3.1.1 Listas con nombres\nAl igual que con los vectores, es posible asignar un nombre a cada uno de los elementos de una lista.\n\nEjemplo 3.21  \n\nlist(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\n\n$nombre\n[1] \"María\"\n\n$edad\n[1] 21\n\n$dirección\n$dirección$calle\n[1] \"Delicias\"\n\n$dirección$número\n[1] 24\n\n$dirección$municipio\n[1] \"Madrid\"\n\n\n\nPara obtener los nombres de una lista se utiliza la siguiente función:\n\nnames(x): Devuelve un vector de cadenas de caracteres con los nombres de los elementos de la lista x.\n\n\nEjemplo 3.22  \n\npersona &lt;- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\nnames(persona)\n\n[1] \"nombre\"    \"edad\"      \"dirección\"\n\n\n\n\n\n\n3.3.2 Tamaño de una lista\nEl número de elementos de una lista es su tamaño y puede averiguarse con la siguiente función:\n\nlenght(x): Devuelve el número de elementos de la lista x.\n\n\nEjemplo 3.23  \n\nlength(list(1, \"dos\", TRUE))\n\n[1] 3\n\nlength(list(1, c(\"dos\", \"tres\"), list(4, \"cinco\")))\n\n[1] 3\n\nlength(list())\n\n[1] 0\n\n\n\n\n\n3.3.3 Acceso a los elementos de una lista\nSe accede a los elementos de una lista de forma similar a los vectores, mediante índices enteros, lógicos o de cadena, entre corchetes [ ].\n\n3.3.3.1 Acceso mediante un índice entero\nAl igual que los vectores, los elementos de una lista están ordenados y se puede utilizar un índice entero para acceder a los elementos que ocupan una determinada posición.\n\nEjemplo 3.24  \n\nx &lt;- list(1, \"dos\", TRUE, 4.5)\n# Acceso al elemento que está en la segunda posición\nx[2]\n\n[[1]]\n[1] \"dos\"\n\n# Acceso a los elementos de las posiciones 1 y 3\nx[c(1, 3)]\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] TRUE\n\n# Acceso a todos los elementos excepto el primero y el cuarto\nx[c(-1, -4)]\n\n[[1]]\n[1] \"dos\"\n\n[[2]]\n[1] TRUE\n\n\n\n\n\n3.3.3.2 Acceso mediante un índice lógico\nCuando se utiliza un índice lógico, se obtienen los elementos correspondientes a las posiciones donde está el valor booleano TRUE.\n\nEjemplo 3.25  \n\nx &lt;- list(1, \"dos\", TRUE, 4.5)\nx[c(T,F,F,T)]\n\n[[1]]\n[1] 1\n\n[[2]]\n[1] 4.5\n\nx &lt; 2\n\nWarning: NAs introducidos por coerción\n\n\n[1]  TRUE    NA  TRUE FALSE\n\n# Filtrado de valores menores que 2\nx[x &lt; 2]\n\nWarning: NAs introducidos por coerción\n\n\n[[1]]\n[1] 1\n\n[[2]]\nNULL\n\n[[3]]\n[1] TRUE\n\n\nObsérvese que para los elementos que no tiene sentido la comparación se obtiene NA, y que el acceso mediante este índice devuelve NULL.\n\n\n\n3.3.3.3 Acceso mediante nombres\nSi los elementos de una lista tienen nombre, se puede acceder a ellos utilizando sus nombres como índices. La única diferencia con el acceso mediante cadenas de vectores es que se obtiene siempre una lista, incluso cuando sólo se quiere acceder a un elemento. Para obtener un elemento, y no una lista con ese único elemento, se utilizan dobles corchetes [[ ]].\n\nEjemplo 3.26  \n\npersona &lt;- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\npersona[c(\"edad\", \"nombre\")]\n\n$edad\n[1] 21\n\n$nombre\n[1] \"María\"\n\npersona[\"nombre\"]\n\n$nombre\n[1] \"María\"\n\ntypeof(persona[\"nombre\"])\n\n[1] \"list\"\n\n# Acceso a un único elemento\npersona[[\"nombre\"]]\n\n[1] \"María\"\n\n# Acceso a una lista anidada\npersona[[\"dirección\"]][[\"municipio\"]]\n\n[1] \"Madrid\"\n\n\n\nUna alternativa a los dobles corchetes es el operador de acceso a listas $. Este operador además permite utilizar coincidencias parciales en los nombres de los elementos para acceder a ellos.\n\n\npersona &lt;- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\n# Acceso a un único elemento\npersona$nombre\n\n[1] \"María\"\n\n# Acceso mediante coincidencia parcial\npersona$nom\n\n[1] \"María\"\n\n# Acceso a una lista anidada\npersona$dirección$municipio\n\n[1] \"Madrid\"\n\n\n\n\n\n\n3.3.4 Modificación de los elementos de una lista\nPara modificar uno o varios elementos de una lista basta con acceder a esos elementos y reasignarles valores con el operador de asignación.\n\nEjemplo 3.27  \n\npersona &lt;- list(\"nombre\" = \"María\", \"edad\" = 21)\npersona$edad &lt;- 22\npersona\n\n$nombre\n[1] \"María\"\n\n$edad\n[1] 22\n\n\n\n\n\n3.3.5 Añadir elementos a una lista\nLa forma más sencilla de añadir un elemento con nombre a una lista es indicando el nombre con el operador $ y asignándole un valor con el operador de asignación &lt;-:\n\nx$nombre &lt;- y: Añade el elemento y a la lista x con el nombre nombre.\n\nEl nuevo elemento se añade siempre al final de la lista.\nPara añadir elementos sin nombre o en una posición determinada se puede utilizar la función append():\n\nappend(x, y, pos): Devuelve la lista vector que resulta de añadir a x los elementos de la lista y, a continuación de la posición pos. El parámetro pos es opcional y si no se indica, los elementos de y se añaden al final de los de x.\n\n\nEjemplo 3.28  \n\npersona &lt;- list(\"nombre\" = \"María\", \"edad\" = 21)\npersona$email &lt;- \"maria@ceu.es\"\npersona\n\n$nombre\n[1] \"María\"\n\n$edad\n[1] 21\n\n$email\n[1] \"maria@ceu.es\"\n\nappend(persona, list(\"sexo\" = \"Mujer\"), 2)\n\n$nombre\n[1] \"María\"\n\n$edad\n[1] 21\n\n$sexo\n[1] \"Mujer\"\n\n$email\n[1] \"maria@ceu.es\"\n\n\n\n\n\n3.3.6 Conversión de una lista en un vector\nEs posible convertir una lista en un vector con la siguiente función:\n\nunlist(x): Devuelve el vector que resulta de aplanar recursivamente la lista x y convertir todos los elementos al mismo tipo mediante coerción de tipos.\n\n\nEjemplo 3.29  \n\npersona &lt;- list(\"nombre\" = \"María\", \"edad\" = 21, \"dirección\" = list(\"calle\" = \"Delicias\", \"número\" = 24, \"municipio\" = \"Madrid\"))\nunlist(persona)\n\n             nombre                edad     dirección.calle    dirección.número \n            \"María\"                \"21\"          \"Delicias\"                \"24\" \ndirección.municipio \n           \"Madrid\" \n\ntypeof(unlist(persona))\n\n[1] \"character\"\n\n\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nObsérvese que cuando se convierte una lista en un vector, los elementos de la lista se convierten al tipo más general mediante coerción."
  },
  {
    "objectID": "03-tipos-datos-estructurados.html#matrices",
    "href": "03-tipos-datos-estructurados.html#matrices",
    "title": "3  Tipos de datos estructurados",
    "section": "3.4 Matrices",
    "text": "3.4 Matrices\nUna matriz es una estructura de datos bidimensional de elementos del mismo tipo organizados en filas y columnas. Una matriz es similar a un vector pero contiene una atributo adicional con sus dimensiones (número de filas y número de columnas).\n\n3.4.1 Creación de matrices\nPara crear una matriz se utiliza la siguiente función:\n\nmatrix(x, nrow = m, ncol = n): Devuelve la matriz con los elementos del vector x organizados en n filas y m columnas. Habitualmente basta con especificar el número de filas o el número de columnas.\n\n\nEjemplo 3.30  \n\nmatrix(1:6, nrow = 2, ncol = 3)\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\nmatrix(1:6, nrow = 2)\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\nmatrix(1:6, ncol = 3)\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n# La matriz de 1 x 1 \nmatrix()\n\n     [,1]\n[1,]   NA\n\n\n\nComo se puede observar en el ejemplo anterior, los elementos se disponen por columnas, pero se pueden disponer los elementos por filas pasando el parámetro byrow = TRUE a la función matrix.\n\nEjemplo 3.31  \n\nmatrix(1:6, nrow = 2)\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\nmatrix(1:6, nrow = 2, byrow = TRUE)\n\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n\n\n\n\n3.4.1.1 Matrices con nombres de filas y columnas\nEs posible poner nombres a las filas y a las columnas de una matriz añadiendo el parámetro dimnames y pasándole una lista de dos vectores de cadenas con los nombres de las filas y las columnas respectivamente.\n\nEjemplo 3.32  \n\nmatrix(1:6, nrow = 2, ncol = 3, dimnames = list(c(\"fila1\", \"fila2\"), c(\"columna1\", \"columna2\", \"columna3\")))\n\n      columna1 columna2 columna3\nfila1        1        3        5\nfila2        2        4        6\n\n\n\nPara obtener los nombres de las filas y las columnas de una matriz se utilizan las siguientes funciones:\n\nrownames(x): Devuelve un vector de cadenas de caracteres con los nombres de las filas de la matriz x.\ncolnames(x): Devuelve un vector de cadenas de caracteres con los nombres de las columnas de la matriz x.\n\n\nEjemplo 3.33  \n\nx &lt;- matrix(1:6, nrow = 2, ncol = 3, dimnames = list(c(\"fila1\", \"fila2\"), c(\"columna1\", \"columna2\", \"columna3\")))\nrownames(x)\n\n[1] \"fila1\" \"fila2\"\n\ncolnames(x)\n\n[1] \"columna1\" \"columna2\" \"columna3\"\n\n\n\n\n\n\n3.4.2 Tamaño y dimensiones de una matriz\nPara obtener el número de elementos y las dimensiones de una matriz se pueden utilizar las siguientes funciones:\n\nlength(x): Devuelve un entero con el número de elementos de la matriz x.\nnrow(x): Devuelve un entero con el número de filas de la matriz x.\nncol(x): Devuelve un entero con el número de columnas de la matriz x.\ndim(x): Devuelve un vector de dos enteros con el número de filas y el número de columnas de la matriz x.\n\n\nEjemplo 3.34  \n\nx &lt;- matrix(1:6, nrow = 2)\nlength(x)\n\n[1] 6\n\nnrow(x)\n\n[1] 2\n\nncol(x)\n\n[1] 3\n\ndim(x)\n\n[1] 2 3\n\n\n\nUsando esta última función se pueden modificar las dimensiones de una matriz asignando un vector de dos enteros con las nuevas dimensiones. Esto también permite crear una matriz a partir de un vector.\n\nEjemplo 3.35  \n\nx &lt;- 1:6\ndim(x) &lt;- c(2, 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\ndim(x) &lt;- c(3, 2)\nx\n\n     [,1] [,2]\n[1,]    1    4\n[2,]    2    5\n[3,]    3    6\n\n\n\n\n\n3.4.3 Acceso a los elementos de una matriz\nPara acceder a los elementos de una matriz se utilizan dos índices (uno para las filas y otro para las columnas), separados por comas y entre corchetes [] a continuación de la matriz. Al igual que para los vectores, los índices pueden ser enteros, lógicos o de cadenas de caracteres.\n\n3.4.3.1 Acceso mediante índices enteros\nPara acceder a los elementos de una matriz mediante índices enteros se indica el número de fila y el número de columna del elemento entre corchetes:\n\nx[i,j]: Devuelve el elemento de la matriz x que está en la fila i y la columna j.\n\nSe puede acceder a más de un elemento indicando un vector de enteros para las filas y otro para las columnas. De esta manera se obtiene una submatriz. Si no se indica la fila o la columna se obtienen todos los elementos de todas las filas o columnas. Al igual que para vectores, se pueden utilizar enteros negativos para descartar filas o columnas\n\nEjemplo 3.36  \n\nx &lt;- matrix(1:9, nrow = 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# Acceso al elemento de la segunda fila y tercera columna\nx[2,3]\n\n[1] 8\n\n# Acceso a la submatriz de la primera y tercera filas, y tercera y segunda columnas\nx[c(1, 3), c(3, 2)]\n\n     [,1] [,2]\n[1,]    7    4\n[2,]    9    6\n\n# Acceso a la primera fila\nx[1, ]\n\n[1] 1 4 7\n\n# Acceso a la segunda columna\nx[, 2]\n\n[1] 4 5 6\n\n# Acceso a la submatriz con todos los elementos salvo la tercera fila y la segunda columna\nx[-3, -2]\n\n     [,1] [,2]\n[1,]    1    7\n[2,]    2    8\n\n\n\n\n\n3.4.3.2 Acceso mediante índices lógicos\nCuando se utilizan índices lógicos, se obtienen los elementos correspondientes a las filas y columnas donde está el valor booleano TRUE.\n\nEjemplo 3.37  \n\nx &lt;- matrix(1:9, nrow = 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\n# Acceso al elemento de la segunda fila y tercera columna\nx[c(F, T, F), c(F, F, T)]\n\n[1] 8\n\n# Acceso a la submatriz de la primera y tercera filas, y segunda y tercera columnas\nx[c(T, F, T), c(F, T, T)]\n\n     [,1] [,2]\n[1,]    4    7\n[2,]    6    9\n\n# Acceso a la primera fila\nx[c(T, F, F), ]\n\n[1] 1 4 7\n\n# Acceso a la segunda columna\nx[, c(F, T, F)]\n\n[1] 4 5 6\n\n\n\n\n\n3.4.3.3 Acceso mediante índices de cadena\nSi las filas y las columnas de una matriz tienen nombre, es posible acceder a sus elementos usando los nombres de las filas y columnas como índices.\n\nEjemplo 3.38  \n\nx &lt;- matrix(1:9, nrow = 3, dimnames = list(c(\"f1\", \"f2\", \"f3\"), c(\"c1\", \"c2\", \"c3\")))\nx\n\n   c1 c2 c3\nf1  1  4  7\nf2  2  5  8\nf3  3  6  9\n\n# Acceso al elemento de la segunda fila y tercera columna\nx[\"f2\", \"c3\"]\n\n[1] 8\n\n# Acceso a la submatriz de la primera y tercera filas, y tercera y segunda columnas\nx[c(\"f1\", \"f3\"), c(\"c3\", \"c2\")]\n\n   c3 c2\nf1  7  4\nf3  9  6\n\n\n\nFinalmente, es posible combinar distintos tipos de índices (enteros, lógicos o de cadena) para indicar las filas y las columnas a las que acceder.\n\n\n\n3.4.4 Pertenencia a una matriz\nPara comprobar si un valor en particular es un elemento de una matriz se puede utilizar el operador %in%:\n\nx %in% y: Devuelve el booleano TRUE si x es un elemento de la matriz y, y FALSE en caso contrario.\n\n\nEjemplo 3.39  \n\nx &lt;- matrix(1:9, nrow = 3)\n2 %in% x\n\n[1] TRUE\n\n-1 %in% x\n\n[1] FALSE\n\n\n\n\n\n3.4.5 Modificación de los elementos de una matriz\nPara modificar uno o varios elementos de una matriz basta con acceder a esos elementos y usar el operador de asignación para asignar nuevos valores.\n\nEjemplo 3.40  \n\nx &lt;- matrix(1:9, nrow = 3)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    8\n[3,]    3    6    9\n\nx[2,3] &lt;- 0\nx\n\n     [,1] [,2] [,3]\n[1,]    1    4    7\n[2,]    2    5    0\n[3,]    3    6    9\n\nx[c(1, 3), 1:2] &lt;- -1\nx\n\n     [,1] [,2] [,3]\n[1,]   -1   -1    7\n[2,]    2    5    0\n[3,]   -1   -1    9\n\n\n\n\n\n3.4.6 Añadir elementos a una matriz\nPara añadir nuevas filas o columnas a una matriz se utilizan las siguientes funciones:\n\nrbind(x, y): Devuelve la matriz que resulta de añadir nuevas filas a la matriz x con los elementos del vector y.\ncbind(x, y): Devuelve la matriz que resulta de añadir nuevas columnas a la matriz x con los elementos del vector y.\n\n\nEjemplo 3.41  \n\nx &lt;- matrix(1:6, nrow = 2)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\n# Añadir una nueva fila\nrbind(x, c(7, 8, 9))\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n[3,]    7    8    9\n\n# Añadir una nueva columna\ncbind(x, c(7, 8))\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    3    5    7\n[2,]    2    4    6    8\n\n\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nObsérvese que si el número de elementos proporcionados en el vector es menor del necesario para completar la fila o columna, se reutilizan los elementos del vector empezando desde el principio.\n\n\n\n\n3.4.7 Trasponer una matriz\nPara trasponer una matriz se utiliza la función siguiente:\n\nt(x): Devuelve la matriz traspuesta de la matriz x.\n\n\nEjemplo 3.42 A continuación se muestran un ejemplo de la trasposición de una matriz.\n\nx &lt;- matrix(1:6, nrow=2)\nt(x)\n\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n[3,]    5    6\n\n\n\n\n\n3.4.8 Operaciones aritméticas con matrices\n\n3.4.8.1 Operaciones aritméticas elemento a elemento\nPara matrices numéricas las operaciones aritméticas habituales se aplican elemento a elemento. Si las dimensiones de las matrices son distintas se produce un error.\n\nEjemplo 3.43  \n\nx &lt;- matrix(1:6, nrow = 2)\nx\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n\ny &lt;- matrix(c(0, 1, 0, -1, 0, 1), nrow = 2)\ny\n\n     [,1] [,2] [,3]\n[1,]    0    0    0\n[2,]    1   -1    1\n\nx + y\n\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    3    3    7\n\nx * y\n\n     [,1] [,2] [,3]\n[1,]    0    0    0\n[2,]    2   -4    6\n\nx / y\n\n     [,1] [,2] [,3]\n[1,]  Inf  Inf  Inf\n[2,]    2   -4    6\n\nx ^ y\n\n     [,1] [,2] [,3]\n[1,]    1 1.00    1\n[2,]    2 0.25    6\n\n\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nObsérvese en el ejemplo anterior que la división por 0 produce el valor Inf que representa infinito.\n\n\n\n\n3.4.8.2 Multiplicación de matrices\nPara multiplicar dos matrices numéricas se utiliza el operador %*%.\n\nEjemplo 3.44  \n\nx &lt;- matrix(1:6, ncol = 3)\ny &lt;- matrix(1:6, nrow = 3)\nx %*% y\n\n     [,1] [,2]\n[1,]   22   49\n[2,]   28   64\n\ny %*% x\n\n     [,1] [,2] [,3]\n[1,]    9   19   29\n[2,]   12   26   40\n[3,]   15   33   51\n\n\n\n\n\n\n\n\n\nAdvertencia\n\n\n\nPara poder multiplicar dos matrices deben tener dimensiones compatibles. Si el número de columnas de la primera matriz no es igual que el número de filas de la segunda se produce un error.\n\n\n\n\n\n3.4.9 Determinante de una matriz\nPara calcular el determinante de una matriz numérica cuadrada se utiliza la siguiente función:\n\ndet(x): Devuelve el determinante de la matriz x. Si x no es una matriz numérica cuadrada produce un error.\n\n\nEjemplo 3.45  \n\nx &lt;- matrix(1:4, ncol = 2)\ndet(x)\n\n[1] -2\n\n\n\n\n\n3.4.10 Inversa de una matriz\nPara calcular la matriz inversa de una matriz numérica cuadrada se utiliza la siguiente función:\n\nsolve(x): Devuelve la matriz inversa de la matriz x. Si x no es una matriz numérica cuadrada produce un error. Si la matriz no es invertible por tener determinante nulo también se obtiene un error.\n\n\nEjemplo 3.46  \n\nx &lt;- matrix(1:4, nrow = 2)\nsolve(x)\n\n     [,1] [,2]\n[1,]   -2  1.5\n[2,]    1 -0.5\n\n# El producto de una matriz por su inversa es la matriz identidad.\nx %*% solve(x)\n\n     [,1] [,2]\n[1,]    1    0\n[2,]    0    1\n\n\n\n\n\n3.4.11 Autovalores y autovectores de una matriz\nPara calcular los autovalores y los autovectores de una matriz numérica cuadrada se utiliza la siguiente función:\n\neigen(x): Devuelve una lista con los autovalores y los autovectores de la matriz x. Para acceder a los autovalores se utiliza el nombre values y para acceder a los autovectores se utiliza el nombre vectors. Si x no es una matriz numérica cuadrada produce un error.\n\n\nEjemplo 3.47  \n\nx &lt;- matrix(1:4, nrow = 2)\nx\n\n     [,1] [,2]\n[1,]    1    3\n[2,]    2    4\n\n# Autovalores\neigen(x)$values\n\n[1]  5.3722813 -0.3722813\n\n# Autovectores\neigen(x)$vectors\n\n           [,1]       [,2]\n[1,] -0.5657675 -0.9093767\n[2,] -0.8245648  0.4159736"
  },
  {
    "objectID": "03-tipos-datos-estructurados.html#data-frames",
    "href": "03-tipos-datos-estructurados.html#data-frames",
    "title": "3  Tipos de datos estructurados",
    "section": "3.5 Data frames",
    "text": "3.5 Data frames\nUn data frame es una estructura bidimensional cuyos elementos se organizan por filas y columnas de manera similar a una matriz. La principal diferencia con las matrices es que sus columnas están formadas por vectores, pero pueden tener tipos de datos distintos. Un data frame es un caso particular de lista formada por vectores del mismo tamaño con nombre.\nLos data frames son las estructuras de datos más utilizadas en R para almacenar los datos en los análisis estadísticos.\n\n3.5.1 Creación de un data frame\nPara crear un data frame se utiliza la siguiente función:\n\ndata.frame(nombrex = x, nombrey = y, ...): Devuelve el data frame con columnas los vectores x, y, etc. y nombres de columna nombrex, nombrey, etc.\n\n\nEjemplo 3.48  \n\ndf &lt;- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5))\ndf\n\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  4.5\n\nstr(df)\n\n'data.frame':   3 obs. of  2 variables:\n $ asignatura: chr  \"Matemáticas\" \"Física\" \"Economía\"\n $ nota      : num  8.5 7 4.5\n\n# Data frame vacío\ndata.frame()\n\ndata frame with 0 columns and 0 rows\n\n\n\nPara grandes conjuntos de datos es más común crear un data frame a partir de un fichero en formato csv mediante la siguiente función:\n\nread.csv(f): Devuelve el data frame que se genera a partir de los datos del fichero csv f. Cada fila del fichero csv se corresponde con una fila del data frame y por defecto utiliza la coma , parara separar los datos de las columnas y punto . como separador de decimales de los datos numéricos. Los nombres de las columnas se obtienen automáticamente a partir de la primera fila del fichero.\nread.csv2(f): Funciona igual que la función anterior pero utiliza como separador de columnas el punto y coma ; y como separador de decimales la coma ,.\n\n\nEjemplo 3.49  \n\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\ndf\n\n                            nombre edad sexo peso altura colesterol\n1     José Luis Martínez Izquierdo   18    H   85   1.79        182\n2                   Rosa Díaz Díaz   32    M   65   1.73        232\n3            Javier García Sánchez   24    H   NA   1.81        191\n4              Carmen López Pinzón   35    M   65   1.70        200\n5             Marisa López Collado   46    M   51   1.58        148\n6                Antonio Ruiz Cruz   68    H   66   1.74        249\n7          Antonio Fernández Ocaña   51    H   62   1.72        276\n8            Pilar Martín González   22    M   60   1.66         NA\n9             Pedro Gálvez Tenorio   35    H   90   1.94        241\n10         Santiago Reillo Manzano   46    H   75   1.85        280\n11           Macarena Álvarez Luna   53    M   55   1.62        262\n12      José María de la Guía Sanz   58    H   78   1.87        198\n13 Miguel Angel Cuadrado Gutiérrez   27    H  109   1.98        210\n14           Carolina Rubio Moreno   20    M   61   1.77        194\n\n\n\n\n\n3.5.2 Coerción de otras estructuras de datos a data frames\nPara convertir otras estructuras de datos en data frames, se utiliza la siguiente función:\n\nas.data.frame(x): Devuelve el data frame que se obtiene a partir la estructura de datos x a plicanco las siguientes reglas de coerción:\n\nSi x es un vector se obtiene un data frame con una sola columna.\nSi x es una lista se obtiene un data frame con tantas columnas como elementos tenga la lista. Si los elementos de la lista tienen tamaños distintos se obtiene un error.\nSi x es una matriz se obtiene un data frame con el mismo número de columnas y filas que la matriz.\n\n\n\n\n3.5.3 Acceso a los elementos de un data frame\nPuesto que un data frame es una lista, se puede acceder a sus elementos como se accede a los elementos de una lista utilizando índices. Con corchetes simples [ ] se obtiene siempre un data frame, mientras que con corchetes dobles [[ ]] o $ se obtiene un vector. Pero también se puede acceder a los elementos de un data frame como si fuese una matriz, indicando un par de índices para las filas y las columnas respectivamente.\n\nEjemplo 3.50  \n\ndf &lt;- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5))\ndf\n\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  4.5\n\n# Acceso como lista\ndf[\"asignatura\"]\n\n   asignatura\n1 Matemáticas\n2      Física\n3    Economía\n\ndf$asignatura\n\n[1] \"Matemáticas\" \"Física\"      \"Economía\"   \n\n# Acceso como matriz\ndf[2:3, \"nota\"]\n\n[1] 7.0 4.5\n\ndf[df$nota &gt;= 5, ]\n\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n\n\n\nObsérvese en el último ejemplo anterior cómo se pueden utilizar condiciones lógicas para filtrar un data frame.\nPara acceder a las primeras o últimas filas de un data frame se pueden utilizar las siguientes funciones:\n\nhead(df, n): Devuelve un data frame con las n primeras filas del data frame df.\ntail(df, n): Devuelve un data frame con las n últimas filas del data frame df.\n\nEstas funciones son útiles para darse una idea del contenido de un data frame con muchas filas.\n\nEjemplo 3.51  \n\ndf &lt;- data.frame(x = 1:26, y = letters) # letters es un vector predefinido con las letras del abecedario.\nhead(df, 3)\n\n  x y\n1 1 a\n2 2 b\n3 3 c\n\ntail(df, 2)\n\n    x y\n25 25 y\n26 26 z\n\n\n\n\n\n3.5.4 Modificación de los elementos de un data frame\nPara modificar uno o varios elementos de un data frame basta con acceder a esos elementos y usar el operador de asignación para asignar nuevos valores.\n\nEjemplo 3.52  \n\ndf &lt;- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5))\ndf\n\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  4.5\n\ndf[3, \"nota\"] &lt;- 5\ndf\n\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  5.0\n\n\n\n\n\n3.5.5 Añadir elementos a un data frame\nPara añadir nuevas filas o columnas a una data frame se utilizan las mismas funciones que para matrices:\n\nrbind(df, x): Devuelve el data frame que resulta de añadir nuevas filas al data frame df con los elementos de la lista x.\ncbind(df, nombrex = x): Devuelve el data frame que resulta de añadir nuevas columnas al data frame df con los elementos del vector x con nombre nombrex.\n\n\nEjemplo 3.53  \n\ndf &lt;- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5))\ndf\n\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  4.5\n\n# Añadir una nueva fila\nrbind(df, list(\"Programación\" , 10))\n\n    asignatura nota\n1  Matemáticas  8.5\n2       Física  7.0\n3     Economía  4.5\n4 Programación 10.0\n\n# Añadir una nueva columna\ncbind(df, créditos = c(6, 4, 3))\n\n   asignatura nota créditos\n1 Matemáticas  8.5        6\n2      Física  7.0        4\n3    Economía  4.5        3\n\n\n\n\n\n3.5.6 Eliminar filas y columnas de un data frame\nPara eliminar una columna de un data frame basta con acceder a la columna y asignarle el valor NULL, mientras que para eliminar una fila basta con acceder a la fila con índice negativo.\n\nEjemplo 3.54  \n\ndf &lt;- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5), créditos = c(6, 4, 3))\ndf\n\n   asignatura nota créditos\n1 Matemáticas  8.5        6\n2      Física  7.0        4\n3    Economía  4.5        3\n\n# Eliminar una columna\ndf$nota &lt;- NULL\ndf\n\n   asignatura créditos\n1 Matemáticas        6\n2      Física        4\n3    Economía        3\n\n# Eliminar una fila\ndf[-2, ]\n\n   asignatura créditos\n1 Matemáticas        6\n3    Economía        3"
  },
  {
    "objectID": "03-tipos-datos-estructurados.html#ejercicios",
    "href": "03-tipos-datos-estructurados.html#ejercicios",
    "title": "3  Tipos de datos estructurados",
    "section": "3.6 Ejercicios",
    "text": "3.6 Ejercicios\n\nEjercicio 3.1 La siguiente tabla recoge las notas de los alumnos de un curso con dos asignaturas.\n\n\n\nAlumno\nSexo\nFísica\nQuímica\n\n\n\n\nCarlos\nH\n6.7\n8.1\n\n\nMaría\nM\n7.2\n9.5\n\n\nCarmen\nM\n5.5\n5\n\n\nPedro\nH\n\n4.5\n\n\nLuis\nH\n3.5\n5\n\n\nSara\nM\n6.2\n4\n\n\n\n\nDefinir cuatro vectores con el nombre, el sexo y las notas de Física y Química.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nnombre &lt;- c(\"Carlos\", \"María\", \"Carmen\", \"Pedro\", \"Luis\", \"Sara\")\nsexo &lt;- c(\"H\", \"M\", \"M\", \"H\", \"H\", \"M\")\nfisica &lt;- c(6.7, 7.2, 5.5, NA, 3.5, 6.2)\nquimica &lt;- c(8.1, 9.5, 5, 4.5, 5, 4)\n\n\n\n\nConvertir el sexo en un factor y mostrar sus niveles.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nsexo &lt;- factor(sexo)\nlevels(sexo)\n\n[1] \"H\" \"M\"\n\n\n\n\n\nCrear un nuevo vector con la nota media de Física y Química.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nmedia &lt;- (fisica + quimica) / 2\nmedia\n\n[1] 7.40 8.35 5.25   NA 4.25 5.10\n\n\n\n\n\nCrear la variable booleana aprobado que tenga el valor TRUE si la media es mayor o igual que 5 y FALSE en caso contrario.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\naprobado &lt;- media &gt;= 5\naprobado\n\n[1]  TRUE  TRUE  TRUE    NA FALSE  TRUE\n\n\n\n\n\nAplicar un filtro al vector de nombres para quedarse con los nombres de los alumnos que han aprobado.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nnombre[aprobado & !is.na(aprobado)]\n\n[1] \"Carlos\" \"María\"  \"Carmen\" \"Sara\"  \n\n\n\n\n\nCrear un data frame con el nombre, sexo y las notas de Física y Química.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ndf &lt;- data.frame(nombre, sexo, fisica, quimica)\ndf\n\n  nombre sexo fisica quimica\n1 Carlos    H    6.7     8.1\n2  María    M    7.2     9.5\n3 Carmen    M    5.5     5.0\n4  Pedro    H     NA     4.5\n5   Luis    H    3.5     5.0\n6   Sara    M    6.2     4.0\n\n\n\n\n\nAñadir el vector con la media al data frame.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ndf$media &lt;- media\ndf\n\n  nombre sexo fisica quimica media\n1 Carlos    H    6.7     8.1  7.40\n2  María    M    7.2     9.5  8.35\n3 Carmen    M    5.5     5.0  5.25\n4  Pedro    H     NA     4.5    NA\n5   Luis    H    3.5     5.0  4.25\n6   Sara    M    6.2     4.0  5.10\n\n\n\n\n\nFiltrar el data frame para quedarse con el nombre y la media de las mujeres que han aprobado.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ndf[sexo == \"M\" & media &gt;= 5, c(\"nombre\", \"media\")]\n\n  nombre media\n2  María  8.35\n3 Carmen  5.25\n6   Sara  5.10"
  },
  {
    "objectID": "04-estructuras-control.html#estructuras-condicionales",
    "href": "04-estructuras-control.html#estructuras-condicionales",
    "title": "4  Estructuras de control",
    "section": "4.1 Estructuras condicionales",
    "text": "4.1 Estructuras condicionales\nLas estructuras condicionales permiten evaluar el estado del programa y tomar decisiones sobre qué código ejecutar en función del mismo.\n\n4.1.1 Condicionales (if)\nLa principal estructura condicional comienza con la palabra reservada if, lleva asociada expresión de tipo lógico o booleano y permite ejecutar un bloque de código dependiendo de si la evaluación de esa expresión es TRUE o FALSE.\n\nif (&lt;exp&gt;) {\n  &lt;código&gt;\n}\n\nSi el resultado de evaluar la expresión &lt;exp&gt; es TRUE entonces se ejecuta el código &lt;código&gt;, mientras que si es FALSE no.\n\n\n\nDiagrama de flujo de la estructura condicional simple\n\n\n\n\n\n\n\nDiagrama de flujo de la estructura condicional simple\n\n\n\n\n\nEjemplo 4.1  \n\nx &lt;- 1\ny &lt;- 0\nif (y != 0){\n  print(x / y)\n}\n\n\nSi se desea ejecutar un bloque de código alternativo cuando no se cumpla la condición se puede añadir a continuación con la palabra reservada else.\n\nif (&lt;exp&gt;) {\n  &lt;código 1&gt;\n} else {\n  &lt;código 2&gt;\n}\n\nEn este caso, si la evaluación de la condición es TRUE se ejecuta el código &lt;código 1&gt; y si es FALSE se ejecuta el código &lt;código 2&gt;.\n\n\n\nDiagrama de flujo de la estructura condicional doble\n\n\n\nEjemplo 4.2  \n\nnota &lt;- 8.5\nif (nota &lt; 5){\n  print(\"Suspenso\")\n} else {\n  print(\"Aprobado\")\n}\n\n[1] \"Aprobado\"\n\n\n\nSe puede comprobar más de una condición encadenando otra instrucción if tras las instrucción else.\n\nif (&lt;exp 1&gt;) {\n  &lt;código 1&gt;\n} else if (&lt;exp 2&gt;) {\n  &lt;código 2&gt;) {\n…\n} else {\n  &lt;código n&gt;\n}\n\nCuando se encadenan múltiples condiciones de esta forma, solamente se ejecuta el bloque de código asociado a la primera condición cuya evaluación sea TRUE. El último bloque de código solamente se ejecuta si todas las condiciones son falsas.\n\n\n\nDiagrama de flujo de la estructura condicional múltiple\n\n\n\nEjemplo 4.3  \n\nnota &lt;- 8.5\nif (nota &lt; 5){\n  print(\"Suspenso\")\n} else if (nota &lt; 7) {\n  print(\"Aprobado\")\n} else if (nota &lt; 9) {\n  print(\"Notable\")\n} else {\n  print(\"Sobresaliente\")\n}\n\n[1] \"Notable\"\n\n\n\n\n\n4.1.2 La función switch()\nOtra forma de tomar decisiones sobre el código a ejecutar es la función switch.\n\nswitch(x, l): Ejecuta el código del valor de la lista l cuyo nombre asociado coincide con el resultado de evaluar la expresión x. Si el resultado de evaluar x no es ningún nombre de los elementos de la lista devuelve NULL.\n\n\nEjemplo 4.4  \n\ntipo.iva &lt;- \"reducido\"\nprecio &lt;- 1000\niva &lt;- precio * switch(tipo.iva, \"superreducido\" = 4, \"reducido\" = 10, \"normal\" = 21) / 100\niva\n\n[1] 100"
  },
  {
    "objectID": "04-estructuras-control.html#bucles",
    "href": "04-estructuras-control.html#bucles",
    "title": "4  Estructuras de control",
    "section": "4.2 Bucles",
    "text": "4.2 Bucles\nUn bucle es una estructura que permite la repetición de un bloque de código. En R existen dos tipos de bucles, los bucles iterativos y los bucles condicionales.\n\n4.2.1 Bucles iterativos (for)\nLo bucles iterativos repiten un bloque de código un número determinado de veces. Comienzan por la palabra reservada for y llevan asociado un iterador, que es una variable que recorre una secuencia de un tipo de datos compuesto, normalmente un vector o una lista. El bloque de código se ejecuta tantas veces como elementos tenga la secuencia, y en cada repetición el iterador toma como valor un elemento distinto de la secuencia.\n\nfor (i in &lt;secuencia&gt;) {\n  &lt;código&gt;\n}\n\n\n\n\nDiagrama de flujo de un bucle iterativo\n\n\n\nEjemplo 4.5 A continuación se muestra varios ejemplos de uso del bucle for.\n\nasignaturas &lt;- c(\"Matemáticas\", \"Física\", \"Programación\")\nfor (i in asignaturas) {\n  print(i)\n}\n\n[1] \"Matemáticas\"\n[1] \"Física\"\n[1] \"Programación\"\n\nfor (i in 1:5) {\n  print(paste(\"El cuadrado de \", i, \" es \", i^2))\n}\n\n[1] \"El cuadrado de  1  es  1\"\n[1] \"El cuadrado de  2  es  4\"\n[1] \"El cuadrado de  3  es  9\"\n[1] \"El cuadrado de  4  es  16\"\n[1] \"El cuadrado de  5  es  25\"\n\n\n\nTambién es posible recorrer los elementos de la secuencia por posición ayudándonos de la siguiente función:\n\nseq_along(x): que devuelve un vector con los enteros desde 1 hasta el número de elementos de la secuencia x.\n\n\nEjemplo 4.6  \n\nasignaturas &lt;- c(\"Matemáticas\", \"Física\", \"Programación\")\nfor (i in seq_along(asignaturas)){\n  print(paste(\"Asignatura \", i, \":\", asignaturas[i]))\n}\n\n[1] \"Asignatura  1 : Matemáticas\"\n[1] \"Asignatura  2 : Física\"\n[1] \"Asignatura  3 : Programación\"\n\n\n\nLos bucles iterativos se utilizan habitualmente para recorrer estructuras de una dimensión como los vectores y las listas, donde se sabe de antemano el número de elementos que contiene y, por tanto, el número de iteraciones del bucle. No obstante, también se pueden recorrer estructuras de más de una dimensión, como por ejemplo matrices, utilizando varios bucles for anidados.\n\nEjemplo 4.7 A continuación se muestra varios ejemplos de dos bucles for anidados para recorrer los elementos de una matriz.\n\nx &lt;- matrix(1:6, 2, 3)\nfor (i in 1:nrow(x)) {\n  for (j in 1:ncol(x)){\n    print(x[i,j])\n  }\n}\n\n[1] 1\n[1] 3\n[1] 5\n[1] 2\n[1] 4\n[1] 6\n\n\n\n\n\n4.2.2 Bucles condicionales (while)\nLos bucles condicionales repiten un bloque de código mientras se cumpla una condición. Comienzan con la palabra reservada while y llevan asociada una expresión lógica, de manera que mientras la evaluación de la expresión lógica sea TRUE se repite la ejecución del bloque de código que contiene.\n\nwhile (&lt;condición&gt;) {\n  &lt;código&gt;\n}\n\nLa expresión lógica &lt;condición&gt; se evalúa antes de ejecutar el bloque de código y solo se ejecuta el &lt;código&gt; si el resultado de la evaluación es TRUE. Obsérvese que cuando el flujo de ejecución del programa llega al bucle while si la condición no es cierta, el código no se ejecuta ni tan siquiera una vez.\n\n\n\nDiagrama de flujo de un bucle condicional\n\n\n\nEjemplo 4.8  \n\ni &lt;- 5\nwhile (i &gt;= 0) {\n  print(i)\n  i &lt;- i - 1\n}\n\n[1] 5\n[1] 4\n[1] 3\n[1] 2\n[1] 1\n[1] 0\n\n\n\n\n\n4.2.3 La instrucción break\nLa instrucción break se utiliza para detener un bucle y salir de él, tanto en bucles iterativos como en bucles condicionales. Normalmente se suele utilizar esta instrucción cuando se cumple una determinada condición en bloque de código del bucle y se decide parar su ejecución y salir del bucle.\n\nEjemplo 4.9  \n\n# Bucle que recorre los números enteros del -2 al 2 pero termina al llegar al 0.\nfor (i in -2:2) {\n  if (i == 0) {\n    break\n  } \n  print(i)\n}\n\n[1] -2\n[1] -1\n\n\n\n\n\n4.2.4 La instrucción next\nLa instrucción next se utiliza para interrumpir la ejecución del bloque de código de un bucle, pero en lugar de salir del bucle pasa a la siguiente iteración. Si se trata de un bucle iterativo el iterador pasa al siguiente elemento de la secuencia de iteración y si se trata de un bucle condicional se pasa evaluar de nuevo la condición de repetición.\n:::{#exm-continuacion-bucle-next}\n\n# Bucle que recorre los enteros del 1 al 10 pero solo imprime los números pares.\nfor (i in 1:10) {\n  if (i %% 2) {\n    next\n  }\n  print(i)\n}\n\n[1] 2\n[1] 4\n[1] 6\n[1] 8\n[1] 10"
  },
  {
    "objectID": "04-estructuras-control.html#ejercicios",
    "href": "04-estructuras-control.html#ejercicios",
    "title": "4  Estructuras de control",
    "section": "4.3 Ejercicios",
    "text": "4.3 Ejercicios\n\nEjercicio 4.1 Crear una función para calcular la media de un vector numérico y usarla para calcular la media del vector (1, 2, NA, 3, 4).\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nmedia &lt;- function(x){\n  suma &lt;- 0\n  n &lt;- 0\n  for (i in x){\n    if (!is.na(i)){\n      suma &lt;- suma + i\n      n &lt;- n + 1\n    }\n  }\n  return(suma / n)\n}\nmedia(c(1, 2, NA, 3, 4))\n\n[1] 2.5\n\n\n\n\n\n\n\nEjercicio 4.2 Usar la función anterior para crear una función para calcular las medias de las columnas de un data frame numérico. La función debe devolver un vector con las medias de las columnas. Usarla para calcular el data frame formado por los vectores (1, 2, NA, 3, 4) y (-1, 0, -2, 0, NA).\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nmedias &lt;- function(df){\nmedias &lt;- NULL\nfor (i in colnames(df)){\n  medias &lt;- c(medias, media(df[[i]]))\n}\nreturn(medias)\n}\n\ndf &lt;- data.frame(x = c(1, 2, NA, 3, 4), y = c(-1, 0, -2, 0, NA))\nmedias(df)\n\n[1]  2.50 -0.75"
  },
  {
    "objectID": "05-funciones.html#definición-y-llamada-a-funciones",
    "href": "05-funciones.html#definición-y-llamada-a-funciones",
    "title": "5  Funciones",
    "section": "5.1 Definición y llamada a funciones",
    "text": "5.1 Definición y llamada a funciones\nPara definir una función se utiliza la siguiente estructura de código:\n\nnombre.funcion &lt;- function (parámetros) {   &lt;código&gt;\n}\n\nEl código que va entre llaves se conoce como cuerpo de la función.\nPara llamar a la función y que se ejecute el código de su cuerpo hay que utilizar el nombre de la función y a continuación los valores pasados a sus parámetros entre paréntesis.\n\nEjemplo 5.1  \n\n# Definición de la función\nsaludo &lt;- function() {\n  print(\"¡Hola!\")\n}\nclass(saludo)\n\n[1] \"function\"\n\n# Llamada a la función\nsaludo()\n\n[1] \"¡Hola!\""
  },
  {
    "objectID": "05-funciones.html#parámetros-y-argumentos-de-una-función",
    "href": "05-funciones.html#parámetros-y-argumentos-de-una-función",
    "title": "5  Funciones",
    "section": "5.2 Parámetros y argumentos de una función",
    "text": "5.2 Parámetros y argumentos de una función\nUna función puede recibir valores cuando se invoca a través de unas variables conocidas como parámetros que se definen entre paréntesis en la declaración de la función. En el cuerpo de la función se pueden usar estos parámetros como si fuesen variables.\nLos valores que se pasan a la función en una llamada o invocación concreta de ella se conocen como argumentos y se asocian a los parámetros de la declaración de la función.\n\nEjemplo 5.2  \n\n# Función con un parámetro\nsaludo &lt;- function(nombre) {\n  print(paste(\"¡Hola \", nombre, \"!\", sep = \"\"))\n}\n# Llamada a la función con un argumento\nsaludo(\"Alf\")\n\n[1] \"¡Hola Alf!\"\n\n\nEn este ejemplo la función saludo tiene un parámetro nombre. En la llamada a la función se pasa la cadena Alf como argumento que se asocia al parámetro nombre en el cuerpo de la función.\n\n\n5.2.1 Paso de argumentos a una función\nLos argumentos de una función pueden pasarse de dos formas:\n\nArgumentos posicionales: Se asocian a los parámetros de la función en el mismo orden que aparecen en la definición de la función.\nArgumentos nominales: Se indica explícitamente el nombre del parámetro al que se asocia un argumento de la forma parametro = argumento. En este caso el orden de los argumentos no importa.\n\n\nEjemplo 5.3  \n\n# Función con un argumento por defecto\narea.triangulo &lt;- function(base, altura) {\n  base * altura / 2\n}\n# Cálculo del área de un triángulo de base 4 y altura 3\n# Paso de argumentos por posición. \narea.triangulo(4, 3)\n\n[1] 6\n\n# Paso de argumentos por nombre\narea.triangulo(altura = 3, base = 4)\n\n[1] 6\n\n\n\n\n\n5.2.2 Argumentos por defecto\nEn la definición de una función se puede asignar a cada parámetro un argumento por defecto, de manera que si se invoca la función sin proporcionar ningún argumento para ese parámetro, se utiliza el argumento por defecto.\n\nEjemplo 5.4  \n\nsaludo &lt;- function(nombre, lenguaje = \"R\") {\n  print(paste(\"¡Hola \", nombre, \"! ¡Bienvenido a \", lenguaje, \"!\", sep = \"\"))\n}\n# Llamada a la función con un argumento\nsaludo(\"Alf\")\n\n[1] \"¡Hola Alf! ¡Bienvenido a R!\""
  },
  {
    "objectID": "05-funciones.html#retorno-de-una-función",
    "href": "05-funciones.html#retorno-de-una-función",
    "title": "5  Funciones",
    "section": "5.3 Retorno de una función",
    "text": "5.3 Retorno de una función\nUna función puede devolver un objeto de cualquier tipo tras su invocación. Para ello se utiliza la función return(), indicando entre paréntesis el valor que devuelve la función. El retorno suele realizarse al final del cuerpo de la función, porque con él finaliza la ejecución de la función y se devuelve el control de la ejecución al punto desde donde se llamó a la función, de manera que cualquier instrucción de cuerpo que vaya después no se ejecutará. Si no se indica ningún objeto, la función devolverá el valor de la última expresión calculada en el cuerpo de la función.\n\nEjemplo 5.5  \n\n# Función que devuelve el area de un triángulo\narea.triangulo &lt;- function(base, altura) {\n  return(base * altura / 2)\n}\narea.triangulo(4, 3)\n\n[1] 6\n\n# Función que devuelve el valor absoluto de un número\nvalor.absoluto &lt;- function(x) {\n  if (x &lt; 0)\n    return(x * -1)\n  else\n    return(x)\n}\nvalor.absoluto(-1)\n\n[1] 1\n\nvalor.absoluto(2)\n\n[1] 2\n\n\n\nPara devolver más de un valor se pueden utilizar estructuras de datos como vectores, listas, matrices o data frames.\n\nEjemplo 5.6  \n\ncirculo &lt;- function(radio) {\n  return(list(perimetro = 2 * pi * radio, area = pi * radio ^ 2))\n}\ncirculo(5)\n\n$perimetro\n[1] 31.41593\n\n$area\n[1] 78.53982\n\ncirculo(5)$perimetro\n\n[1] 31.41593\n\ncirculo(5)$area\n\n[1] 78.53982"
  },
  {
    "objectID": "05-funciones.html#entorno-y-ámbito-de-las-variables",
    "href": "05-funciones.html#entorno-y-ámbito-de-las-variables",
    "title": "5  Funciones",
    "section": "5.4 Entorno y ámbito de las variables",
    "text": "5.4 Entorno y ámbito de las variables\nEl entorno de un programa en R es el conjunto de todos los objetos (funciones, variables, etc.) creados durante la ejecución del programa. Cuando se ejecuta el interprete de R siempre se crea un primer entorno R_GlobalEnv conocido como entorno global. Es posible referirse a él en cualquier momento con la constante .GlobalEnv.\nPara ver el entorno activo en cada momento de la ejecución y el contenido del mismo se utiliza la siguiente función:\n\nenvironment(): Devuelve el nombre del entorno actual.\nls(): Devuelve un vector con los nombres de las objetos (variables, funciones, etc.) que contiene el entorno global.\n\n\nEjemplo 5.7  \n\nx &lt;- 4\ny &lt;- 3\narea.triangulo &lt;- function(base, altura) {\n  base * altura / 2\n}\nenvironment()\n\n&lt;environment: R_GlobalEnv&gt;\n\nls()\n\n[1] \"area.triangulo\" \"x\"              \"y\"             \n\n\n\nComo se puede observar en el ejemplo anterior, los parámetros de la función base y altura no aparecen en el entorno global. En R, cuando se ejecuta una función se crea un nuevo entorno hijo dentro del entorno al que pertenece la función. Durante la ejecución de la función este pasa a ser el entorno activo y cuando termina la ejecución de la función deja de serlo y vuelve a activarse el entorno padre desde donde se llamó a la función.\n\nEjemplo 5.8  \n\nx &lt;- 4\ny &lt;- 3\narea.triangulo &lt;- function(base, altura) {\n  print(\"Entorno de la función area.triangulo\") \n  print(environment())\n  print(ls())\n  return(base * altura / 2)\n}\nprint(\"Entorno fuera de la función\")\n\n[1] \"Entorno fuera de la función\"\n\nenvironment()\n\n&lt;environment: R_GlobalEnv&gt;\n\nls()\n\n[1] \"area.triangulo\" \"x\"              \"y\"             \n\narea.triangulo(x, y)\n\n[1] \"Entorno de la función area.triangulo\"\n&lt;environment: 0x55bb10871900&gt;\n[1] \"altura\" \"base\"  \n\n\n[1] 6\n\n\n\nLos parámetros y los objetos (funciones, variables, etc.) definidos dentro de una función son de ámbito local, mientras que los objetos definidos fuera de ella en alguno de los entornos ancestros son de ámbito global.\nTanto los parámetros como las variables del ámbito local de una función sólo están accesibles durante la ejecución de la función, es decir, cuando termina la ejecución de la función estas variables desaparecen y no son accesibles desde fuera de la función.\nCuando una función declara un objeto (función, variable, etc.) que ya existe en alguno de los entornos ancestros con ámbito global, durante la ejecución de la función el objeto global queda eclipsado por el local y no es accesible hasta que finaliza la ejecución de la función.\n\nEjemplo 5.9  \n\nlenguaje = \"Python\"\nsaludo &lt;- function(lenguaje) {\n  print(paste(\"Bienvenido a\", lenguaje))  \n}\nsaludo(\"R\")\n\n[1] \"Bienvenido a R\"\n\n\nObsérvese cómo al ejecutar la función anterior, la variable lenguaje queda inaccesible al tener la función un parámetro con el mismo nombre.\n\nLas variables globales están accesibles siempre que no sean eclipsadas por otras con el mismo nombre de ámbito local. Si embargo, cuando se intenta asignar un valor a una variable global en el ámbito local, se crea una nueva variable local. Para asignar valores a variables globales en el ámbito local se tiene que utilizar el operador de superasignación &lt;&lt;-. Cuando se utiliza este operador para asignar un valor a una variable, R busca la variable entorno padre, y si no existe continua con la búsqueda en los entornos ancestros hasta llegar a entorno global. Si la búsqueda tiene éxito, asigna el nuevo valor a la variable global, mientras que si no tiene éxito se crea una nueva variable de ámbito local y se le asigna el valor.\n\nEjemplo 5.10  \n\nsaludo &lt;- function() {\n  lenguaje &lt;&lt;- \"R\"\n  return(paste(\"Bienvenido a\", lenguaje))\n}\nlenguaje\n\n[1] \"Python\""
  },
  {
    "objectID": "05-funciones.html#componentes-de-una-función",
    "href": "05-funciones.html#componentes-de-una-función",
    "title": "5  Funciones",
    "section": "5.5 Componentes de una función",
    "text": "5.5 Componentes de una función\nLos tres componentes de una función son:\n\nCuerpo: Es el código dentro de la función.\nParámetros: Es la lista de parámetros que requiere la función.\nEntorno: Es donde se ubican las variables de la función.\n\nPara acceder a estos componentes se pueden utilizar las siguientes funciones:\n\nbody(f): Devuelve el cuerpo de la función f.\nformals(f): Devuelve la lista de parámetros de la función f.\nenvironment(f): Devuelve el entorno de la función f.\n\n\nEjemplo 5.11  \n\n# Definición de la función\narea.triangulo &lt;- function(base, altura) {\n  base * altura / 2\n}\nbody(area.triangulo)\n\n{\n    base * altura/2\n}\n\nformals(area.triangulo)\n\n$base\n\n\n$altura\n\nenvironment(saludo)\n\n&lt;environment: R_GlobalEnv&gt;"
  },
  {
    "objectID": "05-funciones.html#funciones-recursivas",
    "href": "05-funciones.html#funciones-recursivas",
    "title": "5  Funciones",
    "section": "5.6 Funciones recursivas",
    "text": "5.6 Funciones recursivas\nUna función recursiva es una función que en su cuerpo contiene una llama a sí misma.\nLa recursión es una práctica común en la mayoría de los lenguajes de programación ya que permite resolver las tareas recursivas de manera más natural.\nPara garantizar el final de una función recursiva, las sucesivas llamadas tienen que reducir el grado de complejidad del problema, hasta que este pueda resolverse directamente sin necesidad de volver a llamar a la función. De lo contrario la recursión no tendría fin y nunca terminaría la ejecución de la función.\n\nEjemplo 5.12  \n\nfactorial &lt;- function(n) {\n  if (n &lt;= 1) return(n)\n  else return(n * factorial(n - 1))\n}\nfactorial(4)\n\n[1] 24"
  },
  {
    "objectID": "05-funciones.html#paquetes",
    "href": "05-funciones.html#paquetes",
    "title": "5  Funciones",
    "section": "5.7 Paquetes",
    "text": "5.7 Paquetes\nPara facilitar la reutilización código y datos R permite la creación de paquetes que pueden importarse desde otros programas. Un paquete es una colección de código, funciones y datos que se almacenan en un fichero dentro de un directorio llamado library en el entorno de R. Para ver la ubicación de este directorio dentro del sistema de archivos local se puede utilizar la función .libPaths().\n\nEjemplo 5.13  \n\n.libPaths()\n\n[1] \"/home/alf/R/x86_64-pc-linux-gnu-library/4.2\"\n[2] \"/usr/lib/R/library\"                         \n\n\n\nDurante la instalación de R también se instalan varios paquetes básicos que están disponibles en cualquier sesión de trabajo con R. Pero añadir nuevas funciones o procedimientos es necesario instalar el paquete que los contiene y después cargarlo en la sesión de trabajo.\nPara ver los paquetes instalados en un ordenador se utiliza la función library().\n\n5.7.1 Instalación de paquetes\nLa mayor parte de los paquetes para R están disponibles en el repositorio oficial CRAN (Comprehensive R Archive Network), aunque cualquier persona puede desarrollar un paquete y ponerlo a disposición de la comunidad en cualquier otro repositorio.\nExisten distintas formas de instalar un paquete en R:\n\nDirectamente desde el repositorio oficial CRAN\nDesde otros repositorios no oficiales (por ejemplo Github)\nDescargando el paquete e instalándolo manualmente.\n\n\n5.7.1.1 Instalación de paquetes desde el repositorio CRAN\nPara instalar un paquete desde el repositorio oficial CRAN se utiliza la siguiente función:\n\ninstall.packages(x): Obtiene el paquete con el nombre x desde un servidor con el repositorio CRAN y lo instala localmente en el directorio library del entorno de R. Se puede instalar más de un paquete a la vez pasando un vector con los nombres de los paquetes.\n\n\nEjemplo 5.14  \n\ninstall.packages(\"remotes\")\n\n\n\n\n5.7.1.2 Instalación desde otros repositorios (GitHub, GitLab, etc.)\nEl paquete remotes incorpora funciones para instalar paquetes alojados en otros repositorios habituales para el desarrollo de software como GitHub, GitLab, etc.\n\nEjemplo 5.15  \n\ninstall.packages(\"remotes\")\nremotes::install_github(\"rkward-community/rk.Teaching\")\n\n\n\n\n5.7.1.3 Instalación desde Bioconductor\nBioconductor es un repositorio de paquetes especializados en Bioinformática.\nBioconductor utiliza sus propio gestor de paquetes BiocManager, pero la instalación de paquetes es igualmente sencilla.\n\nEjemplo 5.16  \n\ninstall.packages(\"BiocManager\")\nBiocManager::install(\"edgeR\")\n\n\n\n\n5.7.1.4 Instalación manual\nFinalmente es posible instalar un paquete manualmente a partir de su código fuente. Para ello hay previamente hay que descargar el código fuente del paquete en un fichero comprimido en formato zip y después utilizar la siguiente función:\n\ninstall.packages(x, repos = NULL, type = \"source\"): Instala el paquete ubicado en la ruta x del sistema de archivos local en la librería library.\n\nUna vez instalado un paquete ya está disponible para cargarlo en cualquier sesión de trabajo de R y no es necesario volver a instalarlo.\n\n\n\n5.7.2 Carga de un paquete\nUna vez instalado un paquete, para poder ejecutar su contenido es necesario cargarlo en el entorno de trabajo de R. Para ello se utiliza la siguiente función:\n\nlibrary(x): Ejecuta el código del paquete x en la sesión de trabajo activa.\n\n\nEjemplo 5.17  \n\nlibrary(\"remotes\")\n\n\n\n\n5.7.3 Paquetes habituales\nA continuación se presenta una lista ordenada alfabéticamente (no por importancia) de los paquetes más populares para el análisis de datos:\n\ncaret es un paquete para la creación de modelos de clasificación y regresión mediante aprendizaje automático.\ndata.table es un paquete para la manipulación de grandes conjuntos de datos (de hasta 100GB) de manera rápida y eficiente.\ndevtools es un paquete con herramientas para el desarrollo de paquetes en R.\nknitr es un paquete que proporciona un motor para la generación de informes dinámicos que permite la integración de código en R con los lenguajes de procesamiento de textos LaTeX, HTML, Markdown, AsciiDoc o reStructuredText.\nmlr3 es un paquete que proporciona funciones para las principales técnicas de aprendizaje automático.\nplotly es un paquete para la creación de gráficos interactivos.\nrmarkdown es un paquete que facilita el uso del paquete knitr para la elaboración de documentos en múltiples formatos (HTML, pdf, Word y otros) permitiendo la integración de código R en el lenguaje Markdown.\nshiny es un paquete para la construcción de aplicaciones web interactivas.\ntidymodels es una colección de paquetes para la construcción y evalucación de modelos con técnicas de aprendizaje automático.\ntidyverse es una colección de paquetes para la Ciencia de Datos que incluye paquetes para la carga, limpieza, manipulación y representación gráfica de datos."
  },
  {
    "objectID": "06-preprocesamiento.html#la-colección-de-paquetes-tidyverse",
    "href": "06-preprocesamiento.html#la-colección-de-paquetes-tidyverse",
    "title": "6  Preprocesamiento de datos",
    "section": "6.1 La colección de paquetes tidyverse",
    "text": "6.1 La colección de paquetes tidyverse\ntidyverse es una colección de paquetes para la Ciencia de Datos. Incluye los siguientes paquetes:\n\ntibble: Define la estructura de datos tibble que es una versión mejorada de los data frames.\nreadr: Proporciona funciones para la lectura y escritura de tablas de datos en formato plano csv y tsv.\ntidyr: Proporciona funciones para la limpieza y preparación de los datos de manera consistente.\ndplyr: Proporciona una gramática de funciones para la manipulación de datos y las tareas más habituales de preprocesamiento.\nstringr: Proporciona funciones especializadas en la manipulación de cadenas.\nforcats: Proporciona funciones especializadas en la manipulación de factores.\npurrr: Proporciona funciones para la programación funcional que mejoran las ya existentes en R.\nggplot2: Proporciona una gramática de funciones para la realización de gráficos.\n\nEstos paquetes están diseñados bajo una misma filosofía por lo interactúan y se complementan a la perfección."
  },
  {
    "objectID": "06-preprocesamiento.html#tibbles",
    "href": "06-preprocesamiento.html#tibbles",
    "title": "6  Preprocesamiento de datos",
    "section": "6.2 Tibbles",
    "text": "6.2 Tibbles\nEl paquete tibble define la estructura de datos tibble que es similiar a los data frames, pero optimizada, ya que realiza una carga en memoria y evaluación perezosa, lo que hace más eficiente el manejo de grandes volúmenes de datos estructurados en forma de tabla. Los tibbles, además, suelen dar más información sobre el contenido y la estructura de los datos, así como de incoherencias en los datos.\nLos tibbles nunca cambian el tipo de los datos (por ejemplo de cadenas a factores), nunca cambian los nombres de las variables, ni crean nombres de filas, como suelen hacer los data frames.\nAunque los paquetes de tidyverse trabajan perfectamente con data frames, están optimizados para trabajar con tibbles.\nPara convertir un data frame en un tibble se utiliza la función\n\nas_tibble(df): Convierte el data frame df en un tibble.\n\n\nEjemplo 6.1  \n\nlibrary(tibble)\ndf &lt;- data.frame(asignatura = c(\"Matemáticas\", \"Física\", \"Economía\"), nota = c(8.5, 7, 4.5))\ndf\n\n   asignatura nota\n1 Matemáticas  8.5\n2      Física  7.0\n3    Economía  4.5\n\nas_tibble(df)\n\n# A tibble: 3 × 2\n  asignatura   nota\n  &lt;chr&gt;       &lt;dbl&gt;\n1 Matemáticas   8.5\n2 Física        7  \n3 Economía      4.5\n\n\n\nAl igual que los data frames, las columnas de los tibbles son vectores cuyos elementos son del mismo tipo, de manera que suelen representar variables en los estudios estadísticos, mientras que las filas representan individuos, aunque no siempre es así."
  },
  {
    "objectID": "06-preprocesamiento.html#conjuntos-de-datos-ordenados",
    "href": "06-preprocesamiento.html#conjuntos-de-datos-ordenados",
    "title": "6  Preprocesamiento de datos",
    "section": "6.3 Conjuntos de datos ordenados",
    "text": "6.3 Conjuntos de datos ordenados\nExisten dos formas habituales de disponer los datos de un estudio en un data frame o un tibble: formato ancho y formato largo.\n\n\n\nFormatos de un data frame\n\n\nLa mayoría de los paquetes de tidyverse asumen que los datos del data frame o tibble están en formado largo, lo que significa que las columnas del data frame representan variables y las filas observaciones, de manera que cada dato pertenece a una variable y una observación única. Las variables (columnas) contienen valores que miden la misma característica o atributo (edad, estatura, etc.) en cada unidad experimental. Una observación (fila) contiene los valores medidos en la misma unidad experimental (una persona, un día, etc.) en todos atributos estudiados. En resumen, un data frame o tibble esta ordenado (tidy) si\n\nCada columna es una variable\nCada fila es una observación\nCada casilla es un valor\n\nA menudo los conjuntos de datos no están ordenados y violan alguna de de estas condiciones. Lo más común es encontrarnos\n\nEncabezados de columnas que son valores en lugar de variables.\nUna misma columna contiene varias variables.\nVariables que están almacenadas tanto en filas como en columnas.\n\nPara facilitar el preprocesamiento y posterior análisis de los datos es recomendable ordenar el data frame. Para ello el paquete tidyr proporciona dos funciones que permiten pivotar un data frame:\n\npivot_longer(df, columnas, names_to = columna-nombres, values_to = columna-valores): Devuelve el tibble que resulta de convertir las columnas indicadas en el parámetro columnas del data frame df a formato largo, es decir, las columnas se reestructuran en dos nuevas columnas con nombres columna-nombres y columna-valores que contienen los nombres de las columnas originales y sus valores, respectivamente.\npivot_wider(df, names_from = columna-nombres, values_from = columna-valores): Devuelve el tibble que resulta de convertir el data frame df a formato ancho, es decir, se crean tantas columnas como nombres distintos haya en la columna columna-nombres, usando estos nombres como los nombres de las columnas, mientras que los valores se toman de la columna columna-valores.\n\n\n\nlibrary(tidyr)\ndf &lt;- data.frame(nombre = c('María', 'Luis', 'Carmen'), \nedad = c(18, 22, 20), \nMatemáticas = c(8.5, 7, 3.5),\nEconomía = c(8, 6.5, 5),\nProgramación = c(6.5, 4, 9))\ndf\n\n  nombre edad Matemáticas Economía Programación\n1  María   18         8.5      8.0          6.5\n2   Luis   22         7.0      6.5          4.0\n3 Carmen   20         3.5      5.0          9.0\n\n# Pivotar de formato ancho a formato largo\ndf_largo &lt;- pivot_longer(df, Matemáticas:Programación, names_to = \"Asignatura\", values_to = \"Nota\")\ndf_largo\n\n# A tibble: 9 × 4\n  nombre  edad Asignatura    Nota\n  &lt;chr&gt;  &lt;dbl&gt; &lt;chr&gt;        &lt;dbl&gt;\n1 María     18 Matemáticas    8.5\n2 María     18 Economía       8  \n3 María     18 Programación   6.5\n4 Luis      22 Matemáticas    7  \n5 Luis      22 Economía       6.5\n6 Luis      22 Programación   4  \n7 Carmen    20 Matemáticas    3.5\n8 Carmen    20 Economía       5  \n9 Carmen    20 Programación   9  \n\n# Pivotar de formato largo a formato ancho\ndf_ancho &lt;- pivot_wider(df_largo, names_from = Asignatura, values_from = Nota)\ndf_ancho\n\n# A tibble: 3 × 5\n  nombre  edad Matemáticas Economía Programación\n  &lt;chr&gt;  &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt;        &lt;dbl&gt;\n1 María     18         8.5      8            6.5\n2 Luis      22         7        6.5          4  \n3 Carmen    20         3.5      5            9"
  },
  {
    "objectID": "06-preprocesamiento.html#el-paquete-dplyr",
    "href": "06-preprocesamiento.html#el-paquete-dplyr",
    "title": "6  Preprocesamiento de datos",
    "section": "6.4 El paquete dplyr",
    "text": "6.4 El paquete dplyr\nEl paquete dplyr proporciona una gramática para el preprocesamiento de data frames o tibbles, de manera que cada acción sobre data frame se corresponde con un verbo y las funciones que realizan esa acción tienen como nombre el verbo correspondiente. Las funciones de preprocesamiento más habituales incluidas en el paquete dplyr son:\n\ncount: Cuenta el número de observaciones de un data frame.\nselect: Selecciona un subconjunto de columnas de un data frame.\nfilter: Selecciona un subconjunto de filas de un data frame.\narrange: Reordena las filas de un data frame.\nrename: Renombra las columnas de un data frame.\nmutate: Añade nuevas columnas a un data frame o transforma las existentes.\nsummarise: Genera resúmenes estadísticos de las columnas de un data frame.\ngroup_by: Divide las filas de un data frame en grupos de acuerdo a una columna categórica."
  },
  {
    "objectID": "06-preprocesamiento.html#conteo-del-número-de-observaciones",
    "href": "06-preprocesamiento.html#conteo-del-número-de-observaciones",
    "title": "6  Preprocesamiento de datos",
    "section": "6.5 Conteo del número de observaciones",
    "text": "6.5 Conteo del número de observaciones\nPara contar el número de observaciones (filas) de un data frame se utiliza la función\n\ncount(df, columnas): Devuelve el número de filas del data frame df para cada posible combinación de los valores de las columnas indicadas en el parámetro columnas.\n\nEsta función se utiliza habitualmente para calcular tamaños muestrales.\n\n\nlibrary(dplyr)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Contar las filas del data frame\ncount(df)\n\n   n\n1 14\n\n\n\n\n\nlibrary(dplyr)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Contar las filas del data frame\ncount(df, sexo)\n\n  sexo n\n1    H 8\n2    M 6"
  },
  {
    "objectID": "06-preprocesamiento.html#selección-de-variables",
    "href": "06-preprocesamiento.html#selección-de-variables",
    "title": "6  Preprocesamiento de datos",
    "section": "6.6 Selección de variables",
    "text": "6.6 Selección de variables\nPara seleccionar un subconjunto de variables de un data frame se utiliza la función\n\nselect(df, columnas): Devuelve un tibble con las columnas indicadas en el parámetro columnas del data frame df.\n\n\n\nlibrary(dplyr)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Seleccionar las columnas nombre, sexo y edad\nselect(df, nombre, sexo, edad)\n\n                            nombre sexo edad\n1     José Luis Martínez Izquierdo    H   18\n2                   Rosa Díaz Díaz    M   32\n3            Javier García Sánchez    H   24\n4              Carmen López Pinzón    M   35\n5             Marisa López Collado    M   46\n6                Antonio Ruiz Cruz    H   68\n7          Antonio Fernández Ocaña    H   51\n8            Pilar Martín González    M   22\n9             Pedro Gálvez Tenorio    H   35\n10         Santiago Reillo Manzano    H   46\n11           Macarena Álvarez Luna    M   53\n12      José María de la Guía Sanz    H   58\n13 Miguel Angel Cuadrado Gutiérrez    H   27\n14           Carolina Rubio Moreno    M   20\n\n# Seleccionar la primera y tercera columnas\nselect(df, 1, 3)\n\n                            nombre sexo\n1     José Luis Martínez Izquierdo    H\n2                   Rosa Díaz Díaz    M\n3            Javier García Sánchez    H\n4              Carmen López Pinzón    M\n5             Marisa López Collado    M\n6                Antonio Ruiz Cruz    H\n7          Antonio Fernández Ocaña    H\n8            Pilar Martín González    M\n9             Pedro Gálvez Tenorio    H\n10         Santiago Reillo Manzano    H\n11           Macarena Álvarez Luna    M\n12      José María de la Guía Sanz    H\n13 Miguel Angel Cuadrado Gutiérrez    H\n14           Carolina Rubio Moreno    M\n\n# Seleccionar las columnas desde el peso hasta el colesterol\nselect(df, peso:colesterol)\n\n   peso altura colesterol\n1    85   1.79        182\n2    65   1.73        232\n3    NA   1.81        191\n4    65   1.70        200\n5    51   1.58        148\n6    66   1.74        249\n7    62   1.72        276\n8    60   1.66         NA\n9    90   1.94        241\n10   75   1.85        280\n11   55   1.62        262\n12   78   1.87        198\n13  109   1.98        210\n14   61   1.77        194\n\n# Seleccionar todas las columnas menos la edad\nselect(df, -edad)\n\n                            nombre sexo peso altura colesterol\n1     José Luis Martínez Izquierdo    H   85   1.79        182\n2                   Rosa Díaz Díaz    M   65   1.73        232\n3            Javier García Sánchez    H   NA   1.81        191\n4              Carmen López Pinzón    M   65   1.70        200\n5             Marisa López Collado    M   51   1.58        148\n6                Antonio Ruiz Cruz    H   66   1.74        249\n7          Antonio Fernández Ocaña    H   62   1.72        276\n8            Pilar Martín González    M   60   1.66         NA\n9             Pedro Gálvez Tenorio    H   90   1.94        241\n10         Santiago Reillo Manzano    H   75   1.85        280\n11           Macarena Álvarez Luna    M   55   1.62        262\n12      José María de la Guía Sanz    H   78   1.87        198\n13 Miguel Angel Cuadrado Gutiérrez    H  109   1.98        210\n14           Carolina Rubio Moreno    M   61   1.77        194"
  },
  {
    "objectID": "06-preprocesamiento.html#filtrado-de-datos",
    "href": "06-preprocesamiento.html#filtrado-de-datos",
    "title": "6  Preprocesamiento de datos",
    "section": "6.7 Filtrado de datos",
    "text": "6.7 Filtrado de datos\nPara filtrar un data frame y quedarse con las filas que cumplen una condición se usa la función\n\nfilter(df, condicion): Devuelve el tibble con las filas del data frame df que cumplen la condición indicada en el parámetro condición.\n\n\n\nlibrary(dplyr)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Filtrar las mujeres\nfilter(df, sexo == \"M\")\n\n                 nombre edad sexo peso altura colesterol\n1        Rosa Díaz Díaz   32    M   65   1.73        232\n2   Carmen López Pinzón   35    M   65   1.70        200\n3  Marisa López Collado   46    M   51   1.58        148\n4 Pilar Martín González   22    M   60   1.66         NA\n5 Macarena Álvarez Luna   53    M   55   1.62        262\n6 Carolina Rubio Moreno   20    M   61   1.77        194\n\n# Filtrar los hombres mayores de 30 \nfilter(df, sexo == \"H\" & edad &gt; 30)\n\n                      nombre edad sexo peso altura colesterol\n1          Antonio Ruiz Cruz   68    H   66   1.74        249\n2    Antonio Fernández Ocaña   51    H   62   1.72        276\n3       Pedro Gálvez Tenorio   35    H   90   1.94        241\n4    Santiago Reillo Manzano   46    H   75   1.85        280\n5 José María de la Guía Sanz   58    H   78   1.87        198\n\n# Filtrar las filas con valores de colesterol\nfilter(df, !is.na(colesterol))\n\n                            nombre edad sexo peso altura colesterol\n1     José Luis Martínez Izquierdo   18    H   85   1.79        182\n2                   Rosa Díaz Díaz   32    M   65   1.73        232\n3            Javier García Sánchez   24    H   NA   1.81        191\n4              Carmen López Pinzón   35    M   65   1.70        200\n5             Marisa López Collado   46    M   51   1.58        148\n6                Antonio Ruiz Cruz   68    H   66   1.74        249\n7          Antonio Fernández Ocaña   51    H   62   1.72        276\n8             Pedro Gálvez Tenorio   35    H   90   1.94        241\n9          Santiago Reillo Manzano   46    H   75   1.85        280\n10           Macarena Álvarez Luna   53    M   55   1.62        262\n11      José María de la Guía Sanz   58    H   78   1.87        198\n12 Miguel Angel Cuadrado Gutiérrez   27    H  109   1.98        210\n13           Carolina Rubio Moreno   20    M   61   1.77        194\n\n\n\nExiste un filtro bastante habitual que consiste en eliminar las filas de un data frame que contienen algún dado no disponible (NA). Para ello dplyr dispone de la función\n\nna.omit(df): Devuelve el tibble que resulta de eliminar las filas del data frame df con algún valor NA.\n\n\n\nna.omit(df)\n\n                            nombre edad sexo peso altura colesterol\n1     José Luis Martínez Izquierdo   18    H   85   1.79        182\n2                   Rosa Díaz Díaz   32    M   65   1.73        232\n4              Carmen López Pinzón   35    M   65   1.70        200\n5             Marisa López Collado   46    M   51   1.58        148\n6                Antonio Ruiz Cruz   68    H   66   1.74        249\n7          Antonio Fernández Ocaña   51    H   62   1.72        276\n9             Pedro Gálvez Tenorio   35    H   90   1.94        241\n10         Santiago Reillo Manzano   46    H   75   1.85        280\n11           Macarena Álvarez Luna   53    M   55   1.62        262\n12      José María de la Guía Sanz   58    H   78   1.87        198\n13 Miguel Angel Cuadrado Gutiérrez   27    H  109   1.98        210\n14           Carolina Rubio Moreno   20    M   61   1.77        194"
  },
  {
    "objectID": "06-preprocesamiento.html#reordenación-de-datos",
    "href": "06-preprocesamiento.html#reordenación-de-datos",
    "title": "6  Preprocesamiento de datos",
    "section": "6.8 Reordenación de datos",
    "text": "6.8 Reordenación de datos\nPara reordenar las filas de un data frame se utiliza la función\n\narrange(df, columnas): Devuelve un tibble con las mismas filas del data frame df pero ordenadas de acuerdo a los valores de las columnas indicadas en el parámetro columnas. Por defecto, la ordenación es ascendente, para hacerla descendente, hay que aplicar la función desc() a la columna con respecto se quiere ordenar descendentemente.\n\n\n\nlibrary(dplyr)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Ordenar según alfabéticamente por nombre\narrange(df, nombre)\n\n                            nombre edad sexo peso altura colesterol\n1          Antonio Fernández Ocaña   51    H   62   1.72        276\n2                Antonio Ruiz Cruz   68    H   66   1.74        249\n3              Carmen López Pinzón   35    M   65   1.70        200\n4            Carolina Rubio Moreno   20    M   61   1.77        194\n5            Javier García Sánchez   24    H   NA   1.81        191\n6     José Luis Martínez Izquierdo   18    H   85   1.79        182\n7       José María de la Guía Sanz   58    H   78   1.87        198\n8            Macarena Álvarez Luna   53    M   55   1.62        262\n9             Marisa López Collado   46    M   51   1.58        148\n10 Miguel Angel Cuadrado Gutiérrez   27    H  109   1.98        210\n11            Pedro Gálvez Tenorio   35    H   90   1.94        241\n12           Pilar Martín González   22    M   60   1.66         NA\n13                  Rosa Díaz Díaz   32    M   65   1.73        232\n14         Santiago Reillo Manzano   46    H   75   1.85        280\n\n# Ordenar según sexo y edad\narrange(df, sexo, edad)\n\n                            nombre edad sexo peso altura colesterol\n1     José Luis Martínez Izquierdo   18    H   85   1.79        182\n2            Javier García Sánchez   24    H   NA   1.81        191\n3  Miguel Angel Cuadrado Gutiérrez   27    H  109   1.98        210\n4             Pedro Gálvez Tenorio   35    H   90   1.94        241\n5          Santiago Reillo Manzano   46    H   75   1.85        280\n6          Antonio Fernández Ocaña   51    H   62   1.72        276\n7       José María de la Guía Sanz   58    H   78   1.87        198\n8                Antonio Ruiz Cruz   68    H   66   1.74        249\n9            Carolina Rubio Moreno   20    M   61   1.77        194\n10           Pilar Martín González   22    M   60   1.66         NA\n11                  Rosa Díaz Díaz   32    M   65   1.73        232\n12             Carmen López Pinzón   35    M   65   1.70        200\n13            Marisa López Collado   46    M   51   1.58        148\n14           Macarena Álvarez Luna   53    M   55   1.62        262\n\n# Ordenar ascendentemente por sexo y descendentemente por colesterol\narrange(df, sexo, desc(colesterol))\n\n                            nombre edad sexo peso altura colesterol\n1          Santiago Reillo Manzano   46    H   75   1.85        280\n2          Antonio Fernández Ocaña   51    H   62   1.72        276\n3                Antonio Ruiz Cruz   68    H   66   1.74        249\n4             Pedro Gálvez Tenorio   35    H   90   1.94        241\n5  Miguel Angel Cuadrado Gutiérrez   27    H  109   1.98        210\n6       José María de la Guía Sanz   58    H   78   1.87        198\n7            Javier García Sánchez   24    H   NA   1.81        191\n8     José Luis Martínez Izquierdo   18    H   85   1.79        182\n9            Macarena Álvarez Luna   53    M   55   1.62        262\n10                  Rosa Díaz Díaz   32    M   65   1.73        232\n11             Carmen López Pinzón   35    M   65   1.70        200\n12           Carolina Rubio Moreno   20    M   61   1.77        194\n13            Marisa López Collado   46    M   51   1.58        148\n14           Pilar Martín González   22    M   60   1.66         NA"
  },
  {
    "objectID": "06-preprocesamiento.html#renombrado-de-columnas",
    "href": "06-preprocesamiento.html#renombrado-de-columnas",
    "title": "6  Preprocesamiento de datos",
    "section": "6.9 Renombrado de columnas",
    "text": "6.9 Renombrado de columnas\nPara cambiar el nombre de las columnas se utiliza la función\n\nrename(df, nuevo-nombre = columna): Devuelve un tibble con los mismos datos del data frame df pero cambiando el nombre de la columna de nombre columna por nuevo-nombre.\n\n\n\nlibrary(dplyr)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Ordenar según alfabéticamente por nombre\nrename(df, estatura = altura)\n\n                            nombre edad sexo peso estatura colesterol\n1     José Luis Martínez Izquierdo   18    H   85     1.79        182\n2                   Rosa Díaz Díaz   32    M   65     1.73        232\n3            Javier García Sánchez   24    H   NA     1.81        191\n4              Carmen López Pinzón   35    M   65     1.70        200\n5             Marisa López Collado   46    M   51     1.58        148\n6                Antonio Ruiz Cruz   68    H   66     1.74        249\n7          Antonio Fernández Ocaña   51    H   62     1.72        276\n8            Pilar Martín González   22    M   60     1.66         NA\n9             Pedro Gálvez Tenorio   35    H   90     1.94        241\n10         Santiago Reillo Manzano   46    H   75     1.85        280\n11           Macarena Álvarez Luna   53    M   55     1.62        262\n12      José María de la Guía Sanz   58    H   78     1.87        198\n13 Miguel Angel Cuadrado Gutiérrez   27    H  109     1.98        210\n14           Carolina Rubio Moreno   20    M   61     1.77        194"
  },
  {
    "objectID": "06-preprocesamiento.html#creación-de-nuevas-columnas-o-transformación-de-las-existentes",
    "href": "06-preprocesamiento.html#creación-de-nuevas-columnas-o-transformación-de-las-existentes",
    "title": "6  Preprocesamiento de datos",
    "section": "6.10 Creación de nuevas columnas o transformación de las existentes",
    "text": "6.10 Creación de nuevas columnas o transformación de las existentes\nPara crear una nueva columna a partir de otras columnas del data frame se utiliza la función\n\nmutate(df, columna = formula): Devuelve el tibble que resulta de añadir una nueva columna al data frame df con el resultado de aplicar el procedimiento indicado por formula y con el nombre indicado en columna. Si columna es el nombre de una columna ya existente, entonces esa columna se reescribe con los resultados de aplicar la formula.\n\n\n\nlibrary(dplyr)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Cambiar las unidades de la altura a centímetros\nmutate(df, altura = altura*100)\n\n                            nombre edad sexo peso altura colesterol\n1     José Luis Martínez Izquierdo   18    H   85    179        182\n2                   Rosa Díaz Díaz   32    M   65    173        232\n3            Javier García Sánchez   24    H   NA    181        191\n4              Carmen López Pinzón   35    M   65    170        200\n5             Marisa López Collado   46    M   51    158        148\n6                Antonio Ruiz Cruz   68    H   66    174        249\n7          Antonio Fernández Ocaña   51    H   62    172        276\n8            Pilar Martín González   22    M   60    166         NA\n9             Pedro Gálvez Tenorio   35    H   90    194        241\n10         Santiago Reillo Manzano   46    H   75    185        280\n11           Macarena Álvarez Luna   53    M   55    162        262\n12      José María de la Guía Sanz   58    H   78    187        198\n13 Miguel Angel Cuadrado Gutiérrez   27    H  109    198        210\n14           Carolina Rubio Moreno   20    M   61    177        194\n\n# Calcular el índice de masa corporal\nmutate(df, imc = round(peso/altura^2))\n\n                            nombre edad sexo peso altura colesterol imc\n1     José Luis Martínez Izquierdo   18    H   85   1.79        182  27\n2                   Rosa Díaz Díaz   32    M   65   1.73        232  22\n3            Javier García Sánchez   24    H   NA   1.81        191  NA\n4              Carmen López Pinzón   35    M   65   1.70        200  22\n5             Marisa López Collado   46    M   51   1.58        148  20\n6                Antonio Ruiz Cruz   68    H   66   1.74        249  22\n7          Antonio Fernández Ocaña   51    H   62   1.72        276  21\n8            Pilar Martín González   22    M   60   1.66         NA  22\n9             Pedro Gálvez Tenorio   35    H   90   1.94        241  24\n10         Santiago Reillo Manzano   46    H   75   1.85        280  22\n11           Macarena Álvarez Luna   53    M   55   1.62        262  21\n12      José María de la Guía Sanz   58    H   78   1.87        198  22\n13 Miguel Angel Cuadrado Gutiérrez   27    H  109   1.98        210  28\n14           Carolina Rubio Moreno   20    M   61   1.77        194  19"
  },
  {
    "objectID": "06-preprocesamiento.html#resumen-de-datos",
    "href": "06-preprocesamiento.html#resumen-de-datos",
    "title": "6  Preprocesamiento de datos",
    "section": "6.11 Resumen de datos",
    "text": "6.11 Resumen de datos\nPara aplicar una función resumen a una o varias columnas de un data frame se utiliza la función\n\nsumarise(df, nombre-columna = funcion-resumen(columnas)): Devuelve el tibble con la columna de nombre nombre-columna y el valor que resulta de aplicar la función indicada en funcion-resumen a las columnas del data frame df indicadas en columnas.\n\n\n\nlibrary(dplyr)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Calcular la media de la edad\nsummarise(df, edad_media = mean(edad))\n\n  edad_media\n1   38.21429\n\n# Calcular la media y la desviación típica del colesterol\nsummarise(df, media = mean(colesterol, na.rm=T), sd = sd(colesterol, na.rm=T))\n\n     media       sd\n1 220.2308 39.84795"
  },
  {
    "objectID": "06-preprocesamiento.html#resúmenes-por-grupos",
    "href": "06-preprocesamiento.html#resúmenes-por-grupos",
    "title": "6  Preprocesamiento de datos",
    "section": "6.12 Resúmenes por grupos",
    "text": "6.12 Resúmenes por grupos\nLa función summarise suele combinarse con la siguiente función para obtener resúmenes estratificados por grupos.\n\ngroup_by(df, columnas): Devuelve un tibble estratificado de acuerdo a las categorías de las columnas indicadas en columnas. En combinación con la función summarise permite hacer resúmenes estadísticos por grupos.\n\n\n\nlibrary(dplyr)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Estratificar por sexo \ndf.sexo &lt;- group_by(df, sexo)\n# Edades medias por sexo\nsummarise(df.sexo, edad_media = mean(edad))\n\n# A tibble: 2 × 2\n  sexo  edad_media\n  &lt;chr&gt;      &lt;dbl&gt;\n1 H           40.9\n2 M           34.7\n\n# Media y desviación típica del colesterol por sexo\nsummarise(df.sexo, media = mean(colesterol, na.rm=T), sd = sd(colesterol, na.rm=T))\n\n# A tibble: 2 × 3\n  sexo  media    sd\n  &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 H      228.  38.4\n2 M      207.  42.9"
  },
  {
    "objectID": "06-preprocesamiento.html#composición-de-operaciones-mediante-tuberías",
    "href": "06-preprocesamiento.html#composición-de-operaciones-mediante-tuberías",
    "title": "6  Preprocesamiento de datos",
    "section": "6.13 Composición de operaciones mediante tuberías",
    "text": "6.13 Composición de operaciones mediante tuberías\ndplyr permite componer varias operaciones sobre un data frame mediante el operador %&gt;% (pipe), de manera que el data frame que resulta de aplicar una operación se convierte en el data frame de entrada para otra, siguiendo el esquema\ndf %&gt;% operación-1 %&gt;% operación-2 %&gt;% ...\nCuando se utilizan tuberías para componer operaciones de esta forma, no es necesario indicar el data frame como parámetro de la función que define la acción ya que automáticamente se toma el data frame que resulta de la operación anterior.\n\n\nlibrary(dplyr)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicio de la tubería\ndf %&gt;% \n    # Seleccionar sexo, edad y colesterol\n    select(sexo, edad, colesterol) %&gt;%\n    # Filtrar mayores de 30 años\n    filter(edad &gt; 30) %&gt;%\n    # Estratificar por sexo\n    group_by(sexo) %&gt;%\n    # Calcular la media del colesterol\n    summarise(media_colesterol = mean(colesterol))\n\n# A tibble: 2 × 2\n  sexo  media_colesterol\n  &lt;chr&gt;            &lt;dbl&gt;\n1 H                 249.\n2 M                 210."
  },
  {
    "objectID": "06-preprocesamiento.html#ejercicios",
    "href": "06-preprocesamiento.html#ejercicios",
    "title": "6  Preprocesamiento de datos",
    "section": "6.14 Ejercicios",
    "text": "6.14 Ejercicios\n\nEjercicio 6.1 El fichero genetica, contiene información de la análitica fisiológica, microbiológica y bioquímica, de una muestra de ratas tratadas con distintos tratamientos.\n\nCrear un tibble con los datos del fichero.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nlibrary(tidyverse)\ndf &lt;- read_csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/genetica.csv')\ndf\n\n# A tibble: 21 × 20\n   `código muestra` Tratamiento  `mas cor (g)`    IHS     IES     ITS     IAS\n   &lt;chr&gt;            &lt;chr&gt;                &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 Ct-A1            Control               236  0.0433 0.00198 0.00178 0.00043\n 2 Ct-A2            Control               202. 0.044  0.002   0.0017  0.0008 \n 3 Ct-B1            Control               246. 0.042  0.002   0.0015  0.0005 \n 4 Ct-B2            Control               237. 0.0475 0.00238 0.00203 0.00041\n 5 Ct-B3            Control               231. 0.0499 0.002   0.0011  0.0005 \n 6 Ct-C1            Control               235. 0.05   0.0021  0.0033  0.0014 \n 7 Ct-C2            Control               228. 0.05   0.0018  0.0031  0.00059\n 8 Dx-1             Dexametasona          181. 0.061  0.00155 0.0005  0.00012\n 9 Dx-2             Dexametasona          198. 0.063  0.00191 0.0011  0.0002 \n10 Dx-3             Dexametasona          201. 0.0577 0.0017  0.0001  0.0001 \n# ℹ 11 more rows\n# ℹ 13 more variables: `glucog(mg/g)` &lt;dbl&gt;, `pbmc(cel/mL)` &lt;dbl&gt;,\n#   `CD4(cel/µL)` &lt;dbl&gt;, `monoc(cel/mL)` &lt;dbl&gt;, `IHQ: linfB(cel/mm2)` &lt;dbl&gt;,\n#   `pulp.blan(Tx1)` &lt;dbl&gt;, `microorg(log nº/g)` &lt;dbl&gt;, `AI2(absorb)` &lt;dbl&gt;,\n#   `gluc(mmol/L)` &lt;dbl&gt;, `TAG(mmol/L)` &lt;dbl&gt;, `col(mmol/L)` &lt;dbl&gt;,\n#   `HDL(mmol/L)` &lt;dbl&gt;, `ins(pmol/L)` &lt;dbl&gt;\n\n\n\n\n\nConvertir el tratamiento en un factor.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ndf &lt;- mutate(df, Tratamiento = factor(Tratamiento))\n\n\n\n\nCalcular el tamaño muestral de cada grupo de tratamiento\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ncount(df, Tratamiento)\n\n# A tibble: 3 × 2\n  Tratamiento      n\n  &lt;fct&gt;        &lt;int&gt;\n1 Control          7\n2 Dexametasona     7\n3 Kanamicina       7\n\n\n\n\n\nFiltrar las ratas de grupo control con una masa corporal (mas cor (g)) mayor de 230 g.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nfilter(df, Tratamiento == \"Control\" & `mas cor (g)` &gt; 230)\n\n# A tibble: 5 × 20\n  `código muestra` Tratamiento `mas cor (g)`    IHS     IES     ITS     IAS\n  &lt;chr&gt;            &lt;fct&gt;               &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n1 Ct-A1            Control              236  0.0433 0.00198 0.00178 0.00043\n2 Ct-B1            Control              246. 0.042  0.002   0.0015  0.0005 \n3 Ct-B2            Control              237. 0.0475 0.00238 0.00203 0.00041\n4 Ct-B3            Control              231. 0.0499 0.002   0.0011  0.0005 \n5 Ct-C1            Control              235. 0.05   0.0021  0.0033  0.0014 \n# ℹ 13 more variables: `glucog(mg/g)` &lt;dbl&gt;, `pbmc(cel/mL)` &lt;dbl&gt;,\n#   `CD4(cel/µL)` &lt;dbl&gt;, `monoc(cel/mL)` &lt;dbl&gt;, `IHQ: linfB(cel/mm2)` &lt;dbl&gt;,\n#   `pulp.blan(Tx1)` &lt;dbl&gt;, `microorg(log nº/g)` &lt;dbl&gt;, `AI2(absorb)` &lt;dbl&gt;,\n#   `gluc(mmol/L)` &lt;dbl&gt;, `TAG(mmol/L)` &lt;dbl&gt;, `col(mmol/L)` &lt;dbl&gt;,\n#   `HDL(mmol/L)` &lt;dbl&gt;, `ins(pmol/L)` &lt;dbl&gt;\n\n\n\n\n\nCalcular la media y la desviación típica de la masa corporal (mas cor (g)) para cada tratamiento.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ndf %&gt;%\n    group_by(Tratamiento) %&gt;%\n    summarise(media = mean(`mas cor (g)`), desv.est = sd(`mas cor (g)`))\n\n# A tibble: 3 × 3\n  Tratamiento  media desv.est\n  &lt;fct&gt;        &lt;dbl&gt;    &lt;dbl&gt;\n1 Control       231.     13.6\n2 Dexametasona  191.     14.2\n3 Kanamicina    229.     13.9\n\n\n\n\n\nCalcular la media y la desviación típica de todas las variables para cada tratamiento.\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ndf %&gt;%\n    pivot_longer(-c(`código muestra`, Tratamiento), names_to = \"Variable\", values_to = \"Valor\") %&gt;%\n    group_by(Variable) %&gt;%\n    summarise(media = mean(Valor), desv.est = sd(Valor))\n\n# A tibble: 18 × 3\n   Variable              media desv.est\n   &lt;chr&gt;                 &lt;dbl&gt;    &lt;dbl&gt;\n 1 AI2(absorb)         2.86e-1  1.63e-1\n 2 CD4(cel/µL)         1.05e+3  1.50e+3\n 3 HDL(mmol/L)         1.49e+0  6.20e-1\n 4 IAS                 5.26e-4  3.92e-4\n 5 IES                 1.96e-3  1.96e-4\n 6 IHQ: linfB(cel/mm2) 7.95e+1  7.62e+1\n 7 IHS                 5.14e-2  7.12e-3\n 8 ITS                 1.80e-3  8.63e-4\n 9 TAG(mmol/L)         3.98e+0  2.09e+0\n10 col(mmol/L)         2.44e+0  1.29e+0\n11 gluc(mmol/L)        3.57e+1  1.88e+1\n12 glucog(mg/g)        7.83e+1  3.81e+1\n13 ins(pmol/L)         1.91e+2  1.05e+2\n14 mas cor (g)         2.17e+2  2.28e+1\n15 microorg(log nº/g)  2.35e+0  1.61e+0\n16 monoc(cel/mL)       1.32e+4  4.68e+3\n17 pbmc(cel/mL)        1.27e+7  2.10e+7\n18 pulp.blan(Tx1)      2.75e-1  1.12e-1"
  },
  {
    "objectID": "07-graficos.html#gramática-de-gráficos-y-el-paquete-ggplot2",
    "href": "07-graficos.html#gramática-de-gráficos-y-el-paquete-ggplot2",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.1 Gramática de gráficos y el paquete ggplot2",
    "text": "7.1 Gramática de gráficos y el paquete ggplot2\nEl paquete ggplot2 forma parte de la colección de paquetes tidyverse que ya se introdujo en la sección anterior.\nEste paquete implementa la gramática de gráficos descrita por Leland Wilkinson, que proporciona un sistema formal para representar distintas variables mediante distintos atributos gráficos (aesthetics) como la forma, el tamaño o el color de objetos geométricos como puntos, líneas o barras. Esto hace que la creación de gráficos con este paquete sea, en general, más intuitiva una vez se entiende la lógica de la gramática.\nEn general, para definir un gráfico con ggplot2 se suelen definir los siguientes elementos:\n\nDatos. Los datos deben estar contenidos en un data frame o tibble en formato ordenado (tidy).\nAtributos (aesthetics). Las variables que quieren representarse en el gráfico deben asociarse a atributos gráficos como los ejes x, y, z, el color, el tamaño, la forma de los objetos geométricos.\nCapas de objetos geométricos (geoms). Están formadas por elementos geométricos (puntos, líneas, barras, etc.) cuya posición, forma, tamaño y color, depende de los atributos.\nEscalas. Definen la escala para los ejes del diagrama así como las leyendas para el resto de atributos.\nSistema de coordenadas. Describe el sistema de coordenadas utilizado para representar los objetos geométricos en el plano o en el espacio (normalmente el sistema cartesiano).\nFacetas. Permite descomponer un gráfico en múltiples gráficos para distintos subconjuntos del conjunto de datos.\nTema. Permite cambiar elementos secundarios del gráfico como el tipo de letra de las etiquetas y leyendas, el tamaño de la fuente, el color de fondo, aspecto final del los gráficos.\n\n\n\n\nGramática de gráficos de ggplot2\n\n\nEstos elementos se suelen añadir por capas al gráfico mediante el operador +."
  },
  {
    "objectID": "07-graficos.html#inicialización-de-un-gráfico",
    "href": "07-graficos.html#inicialización-de-un-gráfico",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.2 Inicialización de un gráfico",
    "text": "7.2 Inicialización de un gráfico\nPara dibujar un gráfico con ggplot2 debemos comenzar por la siguiente función\n\nggplot(df, aes(atributo1 = var1, atributo2 = var2, ...)): Inicializa un gráfico con las variables var1, var2, etc. del data frame df asociadas a los atributos atributo1, atributo2, etc. respectivamente. Los atributos pueden más comunes son:\n\nx: Posición en el eje x del objeto geométrico.\ny: Posición en el eje y del objeto geométrico.\nz: Posición en el eje z del objeto geométrico.\nshape: Forma del punto.\nsize: Tamaño del punto.\nlinetype: Forma de la línea.\nlinewidth: Anchura de la línea.\ncolour: Color del objeto geométrico.\nfill: Color de relleno del objeto geométrico.\n\n\n\n\n\n\n\n\nImportante\n\n\n\nTodos los atributos se indican dentro de la función aes()."
  },
  {
    "objectID": "07-graficos.html#diagramas-de-puntos",
    "href": "07-graficos.html#diagramas-de-puntos",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.3 Diagramas de puntos",
    "text": "7.3 Diagramas de puntos\nPara dibujar un diagrama de puntos se utiliza la capa de objetos geométricos\n\ngeom_point(): Dibuja un diagrama de líneas que unen los puntos con coordenadas dadas por los pares de valores de las variables asociadas a los atributos x e y.\n\nEsta capa es ideal para representar diagramas de dispersión.\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/temperaturas.csv') %&gt;%\n    mutate(Día = factor(Día, levels = c(\"L\", \"M\", \"X\", \"J\", \"V\", \"S\", \"D\")))\n# Filtrar los datos de Madrid\ndf.madrid = filter(df, Ciudad == \"Madrid\")\n# Inicializar el gráfico con el día en el atributo x y la temperatura en el atributo y.\nggplot(df.madrid, aes(x = Día, y = Temperatura)) +\n# Añadir la capa de los puntos.\n    geom_point()\n\n\n\n\n\n\n\n# Inicializar el gráfico con el día en el atributo x, la temperatura en el atributo y, y la ciudad en el atributo shape.\nggplot(df, aes(x = Día, y = Temperatura, shape = Ciudad)) +\n# Añadir la capa de los puntos.\n    geom_point()\n\n\n\n\n\n\n\n# Inicializar el gráfico con el día en el atributo x, la temperatura en el atributo y, y la ciudad en el atributo colour.\nggplot(df, aes(x = Día, y = Temperatura, colour = Ciudad)) +\n# Añadir la capa de los puntos.\n    geom_point()\n\n\n\n\n\n\n\nlibrary(ggplot2)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con la altura en el atributo x y el peso en el atributo y.\nggplot(df, aes(x = altura, y = peso)) +\n# Añadir la capa de los puntos.\n    geom_point()\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n# Inicializar el gráfico con la altura en el atributo x, el peso en el atributo y, y el sexo en el atributo colour.\nggplot(df, aes(x = altura, y = peso, colour = sexo)) +\n# Añadir la capa de los puntos.\n    geom_point()\n\nWarning: Removed 1 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\nMás información sobre geom_point."
  },
  {
    "objectID": "07-graficos.html#diagramas-de-líneas",
    "href": "07-graficos.html#diagramas-de-líneas",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.4 Diagramas de líneas",
    "text": "7.4 Diagramas de líneas\nPara dibujar un diagrama de líneas se utiliza la capa de objetos geométricos\n\ngeom_line(): Dibuja un diagrama de líneas que unen los puntos con coordenadas dadas por los pares de valores de las variables asociadas a los atributos x e y. Cuando la variable asociada al atributo x es un factor, debe asociarse también una variable al atributo group para determina los grupos que se unirán mediante líneas. Si solo hay un grupo debe indicarse group = 1.\n\nEsta capa es ideal para representar series temporales.\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/temperaturas.csv') %&gt;%\n    mutate(Día = factor(Día, levels = c(\"L\", \"M\", \"X\", \"J\", \"V\", \"S\", \"D\")))\n# Filtrar los datos de Madrid\ndf.madrid = filter(df, Ciudad == \"Madrid\")\n# Inicializar el gráfico con el día en el atributo x y la temperatura en el atributo y. \nggplot(df.madrid, aes(x = Día, y = Temperatura, group = 1)) +\n# Añadir la capa de las lineas.\n    geom_line()\n\n\n\n\n\n\n\n# Inicializar el gráfico con el día en el atributo x, la temperatura en el atributo y, y la ciudad en los atributos group y linetype.\nggplot(df, aes(x = Día, y = Temperatura, group = Ciudad, linetype = Ciudad)) +\n# Añadir la capa de las lineas.\n    geom_line()\n\n\n\n\n\n\n\n# Inicializar el gráfico con el día en el atributo x, la temperatura en el atributo y, y la ciudad en los atributos group y colour.\nggplot(df, aes(x = Día, y = Temperatura, group = Ciudad, colour = Ciudad)) +\n# Añadir la capa de las lineas.\n    geom_line()\n\n\n\n\n\nMás información sobre geom_line."
  },
  {
    "objectID": "07-graficos.html#diagramas-de-barras",
    "href": "07-graficos.html#diagramas-de-barras",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.5 Diagramas de barras",
    "text": "7.5 Diagramas de barras\nPara dibujar un diagrama de barras se utiliza la capa de objetos geométricos\n\ngeom_bar(aes(weight = var)): Dibuja un diagrama de barras con la variable asociada al atributo x o y (si se usa el atributo x las barras son verticales y se usa y horizontales), donde la altura de las barras viene dada por la variable var. Si no se indica Por defecto, la altura de las barras representa la frecuencia absoluta de cada valor de la variable. Si no se indica el atributo weight la altura de las barras es la frecuencia absoluta de los valores de la variable asociada a los atributos x o y.\n\n\n\nlibrary(dplyr)\nlibrary(ggplot2)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/temperaturas.csv') %&gt;%\n    mutate(Día = factor(Día, levels = c(\"L\", \"M\", \"X\", \"J\", \"V\", \"S\", \"D\")))\ndf\n\n      Ciudad Día Temperatura\n1     Madrid   L        28.5\n2     Madrid   M        30.5\n3     Madrid   X        31.0\n4     Madrid   J        30.0\n5     Madrid   V        28.0\n6     Madrid   S        27.5\n7     Madrid   D        30.5\n8  Barcelona   L        24.5\n9  Barcelona   M        25.5\n10 Barcelona   X        26.5\n11 Barcelona   J        25.0\n12 Barcelona   V        26.5\n13 Barcelona   S        24.5\n14 Barcelona   D        25.0\n\n# Filtrar los datos de Madrid\ndf.madrid = filter(df, Ciudad == \"Madrid\")\n# Inicializar el gráfico con el día en el atributo x.\nggplot(df.madrid, aes(x = Día)) +\n# Añadir la capa de las barras con altura la temperatura.\n    geom_bar(aes(weight = Temperatura))\n\n\n\n\n\n\n\n# Inicializar el gráfico con el día en el atributo y.\nggplot(df.madrid, aes(y = Día)) +\n# Añadir la capa de las barras con altura la temperatura.\n    geom_bar(aes(weight = Temperatura))\n\n\n\n\n\n\n\n# Inicializar el gráfico con el día en el atributo x y la ciudad en el color de relleno.\nggplot(df, aes(x = Día, fill = Ciudad)) +\n# Añadir la capa de las barras con altura la temperatura (por defecto barras acumuladas).\n    geom_bar(aes(weight = Temperatura))\n\n\n\n\n\n\n\n# Inicializar el gráfico con el día en el atributo x y la ciudad en el color de relleno.\nggplot(df, aes(x = Día, fill = Ciudad)) +\n# Añadir la capa de las barras con altura la temperatura indicando barras separadas.\n    geom_bar(aes(weight = Temperatura), position = \"dodge\")\n\n\n\n\n\n\n\nlibrary(ggplot2)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con el sexo en el atributo x.\nggplot(df, aes(x = sexo)) +\n# Añadir la capa de las barras.\n    geom_bar()\n\n\n\n\n\n\n\n# Inicializar el gráfico con el sexo en los atributos x y fill.\nggplot(df, aes(x = sexo, fill = sexo)) +\n# Añadir la capa de las barras.\n    geom_bar() \n\n\n\n\n\nMás información sobre geom_bar."
  },
  {
    "objectID": "07-graficos.html#histogramas",
    "href": "07-graficos.html#histogramas",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.6 Histogramas",
    "text": "7.6 Histogramas\nPara dibujar un histograma se utiliza la capa de objetos geométricos\n\ngeom_histogram(bins = clases, binwidth = anchura): Dibuja un histograma de la variable asociada al atributo x usando el número de clases indicado por clases o bien clases de amplitud indicada por anchura. Si no se indica el parámetro bins o bindwidth se toman 30 clases por defecto.\n\n\n\nlibrary(ggplot2)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con la edad en el atributo x.\nggplot(df, aes(x = altura)) +\n# Añadir la capa del histograma.\n    geom_histogram()\n\n\n\n\n\n\n\n# Inicializar el gráfico con la edad en el atributo x.\nggplot(df, aes(x = altura)) +\n# Añadir la capa del histograma con anchura de clases 5.\n    geom_histogram(binwidth = 0.1)\n\n\n\n\n\n\n\n# Inicializar el gráfico con la edad en el atributo x y el sexo en el atributo fill.\nggplot(df, aes(x = altura, fill = sexo)) +\n# Añadir la capa del histograma con anchura de clases 10.\n    geom_histogram(binwidth = 0.1)\n\n\n\n\n\n\n\n# Inicializar el gráfico con la edad en el atributo x y el sexo en el atributo fill.\nggplot(df, aes(x = altura, fill = sexo)) +\n# Añadir la capa del histograma con anchura de clases 10.\n    geom_histogram(binwidth = 0.1,alpha=0.4, position=\"identity\")\n\n\n\n\n\nMás información sobre geom_histogram."
  },
  {
    "objectID": "07-graficos.html#diagramas-de-densidad",
    "href": "07-graficos.html#diagramas-de-densidad",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.7 Diagramas de densidad",
    "text": "7.7 Diagramas de densidad\nPara dibujar un diagrama de densidad se utiliza la capa de objetos geométricos\n\ngeom_density(): Dibuja un diagrama de densidad de probabilidad estimada de los valores de la variable asociada al atributo x.\n\nEste diagrama es una alternativa a los histogramas para representar la distribución de probabilidad de los valores de una variable.\n\n\nlibrary(ggplot2)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con la edad en el atributo x.\nggplot(df, aes(x = edad)) +\n# Añadir la capa de la densidad de probabilidad.\n    geom_density()\n\n\n\n\n\n\n\n# Inicializar el gráfico con la edad en el atributo x y el sexo en el atributo colour.\nggplot(df, aes(x = edad, colour = sexo)) +\n# Añadir la capa de la densidad de probabilidad.\n    geom_density()\n\n\n\n\n\nMás información sobre geom_density."
  },
  {
    "objectID": "07-graficos.html#diagramas-de-cajas",
    "href": "07-graficos.html#diagramas-de-cajas",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.8 Diagramas de cajas",
    "text": "7.8 Diagramas de cajas\nPara dibujar un diagrama de caja y bigotes se utiliza la capa de objetos geométricos\n\ngeom_boxplot(): Dibuja un diagrama de caja y bigotes de la variable asociada al atributo x o y. Si se utiliza el atributo x la caja se representa horizontalmente, y si se utiliza el atributo y verticalmente.\n\n\n\nlibrary(ggplot2)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con el colesterol en el atributo x.\nggplot(df, aes(x = colesterol)) +\n# Añadir la capa de la caja.\n    geom_boxplot()\n\nWarning: Removed 1 rows containing non-finite values (`stat_boxplot()`).\n\n\n\n\n\n\n\n\n# Inicializar el gráfico con la altura en el atributo y y el sexo en el atributo fill.\nggplot(df, aes(y = altura, fill = sexo)) +\n# Añadir la capa de la caja.\n    geom_boxplot()\n\n\n\n\n\nMás información sobre geom_boxplot."
  },
  {
    "objectID": "07-graficos.html#diagrama-de-sectores",
    "href": "07-graficos.html#diagrama-de-sectores",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.9 Diagrama de sectores",
    "text": "7.9 Diagrama de sectores\nPara dibujar un diagrama de sectores se utiliza la misma capa de objetos geométricos que para los diagramas de barras (geom_bar) pero añadiendo el sistema de coordenadas polares.\n\ncoor_polar(theta = \"x\"|\"y\"): Cambia al sistema de coordenadas cartesianas polares, donde el ángulo viene dado por la variable asociada al atributo “x” o el atributo “y”.\n\n\n\nlibrary(ggplot2)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con el sexo en el atributo x.\nggplot(df, aes(x = \"\", fill = sexo)) +\n# Añadir la capa de las barras.\n    geom_bar() +\n# Añadir el sistema de coordenadas polares\n    coord_polar(theta = \"y\")"
  },
  {
    "objectID": "07-graficos.html#interpolación-y-ajustes-de-regresión",
    "href": "07-graficos.html#interpolación-y-ajustes-de-regresión",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.10 Interpolación y ajustes de regresión",
    "text": "7.10 Interpolación y ajustes de regresión\nPara dibujar una línea de interpolación o de ajuste de regresión se utiliza la capa de objetos geométricos\n\ngeom_smooth(method = ajuste, formula = ecuación): Dibuja una línea de ajuste para los puntos con coordenadas dadas por los pares de valores de las variables asociadas a los atributos x e y, usando el método de ajuste dado por por ajuste y la fórmula dada por ecuación. Los métodos de ajuste más habituales son:\n\n\"loess\": Ajuste de regresión polinomial local. Es la que se utiliza por defecto.\n\"lm\": Ajuste de regresión de modelos lineal por mínimos cuadrados.\n\"glm\": Ajuste de regresión modelos lineales generalizados por mínimos cuadrados. Por defecto se dibujan también las bandas con el error estándar del ajuste. Para desactivar estas bandas se debe indicar también el parámetro se = FALSE.\n\n\nEsta capa suele usarse en combinación con la capa de puntos para diagramas de dispersión.\n\n\nlibrary(ggplot2)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con la altura en el atributo x y el peso en el atributo y.\nggplot(df, aes(x = altura, y = peso)) +\n# Añadir la capa de puntos.\n    geom_point() +\n# Añadir la capa de ajuste de regresión polinomial local loess\n    geom_smooth()\n\n\n\n\n\n\n\n# Inicializar el gráfico con la altura en el atributo x y el peso en el atributo y.\nggplot(df, aes(x = altura, y = peso)) +\n# Añadir la capa de puntos.\n    geom_point() +\n# Añadir la capa de ajuste de regresión lineal por mínimos cuadrados.\n    geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n# Inicializar el gráfico con la altura en el atributo x, el peso en el atributo y, y el sexo en el atributo colour.\nggplot(df, aes(x = altura, y = peso, colour = sexo)) +\n# Añadir la capa de puntos.\n    geom_point() +\n# Añadir la capa de ajuste de regresión lineal por mínimos cuadrados sin las bandas de error.\n    geom_smooth(method = \"lm\", se = FALSE)\n\n\n\n\n\nMás información sobre geom_smooth."
  },
  {
    "objectID": "07-graficos.html#facetas",
    "href": "07-graficos.html#facetas",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.11 Facetas",
    "text": "7.11 Facetas\nLas facetas permiten desagregar un gráfico según los grupos de uno o varios factores del conjunto de datos. Para añadir facetas a un gráfico se añade la función\n\nfacet_wrap(vars(var1, var2,...), nrow = n, ncol = m): Crea un un gráfico para cada combinación de valores de las variables var1, var2, etc. y los coloca en una tabla de n filas y m columnas.\n\n\n\nlibrary(ggplot2)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con la altura en el atributo x y el peso en el atributo y.\nggplot(df, aes(x = altura, y = peso)) +\n# Añadir la capa de puntos\n    geom_point() +\n# Añadir la capa de ajuste de regresión lineal por mínimos cuadrados.\n    geom_smooth(method = \"lm\") +\n# Añadir la faceta del sexo.\n    facet_wrap(vars(sexo))\n\n\n\n\n\nMás información sobre facetas."
  },
  {
    "objectID": "07-graficos.html#personalización-de-gráficos",
    "href": "07-graficos.html#personalización-de-gráficos",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.12 Personalización de gráficos",
    "text": "7.12 Personalización de gráficos\nggplot incluye multitud de posibilidades de personalización de gráficos. Aquí veremos solo las más habituales.\n\n7.12.1 Títulos\nPara poner un título al gráfico, a los ejes o a la leyenda se añade la función\n\nlabs(title = título, x = titulo-x, y = titulo-y,\ncolour = leyenda-color, shape  = leyenda-forma)\n\n\n\nlibrary(ggplot2)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con la altura en el atributo x y el peso en el atributo y.\nggplot(df, aes(x = altura, y = peso)) +\n# Añadir la capa de puntos.\n    geom_point() +\n# Añadir un título al gráfico y a los ejes.\n    labs(title = \"Diagrama de dispersión\", x = \"Altura (m)\", y = \"Peso (kg)\")\n\n\n\n\n\n\n\n7.12.2 Escalas\nPara cambiar las escalas de los ejes cartesianos se añaden la funciones\n\nscale_x_continuos(limits = rango, breaks = cortes, labels = etiquetas, trans = transformación): Restringe escala del eje x al rango indicado por rango, incluye las marcas en eje indicadas por cortes con las etiquetas indicadas por etiquetas y aplica la transformación de escala indicada por transformación. Las transformaciones de escala más habituales son \"log2\" (logarítmo en base 2), \"log10\" (logarítmo en base 10) y sqrt (raíz cuadrada).\nscale_y_continuos(limits = rango, breaks = cortes, labels = etiquetas, trans = transformación): Igual que la función anterior pero para el eje y.\n\n\n\nlibrary(ggplot2)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con la altura en el atributo x y el peso en el atributo y.\nggplot(df, aes(x = altura, y = peso)) +\n# Añadir la capa de los puntos.\n    geom_point() +\n# Cambiar el rango y las marcas de la escala del eje x\n    scale_x_continuous(limits = c(1.5, 2.1), breaks = seq(1.5, 2.1, 0.1)) +\n# Aplicar una transformación logarítmica a la la escala del eje y\n    scale_y_continuous(trans = \"log2\", breaks = seq(50, 110, 10))\n\n\n\n\n\n\n\n7.12.3 Temas\nFinalmente se para cambiar otros aspectos del gráfico como las fuentes o los colores de fondos se utilizan temas. Para indicar o modificar un tema se añade la función\n\ntheme(propiedades): Modifica las propiedades del tema indicadas. La lista es demasiado grande para cubrirla en este tutorial, por lo que se recomienda ver todas las opciones en la documentación de ggplot2.\n\n\n\nlibrary(ggplot2)\ndf &lt;- read.csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/colesterol.csv')\n# Inicializar el gráfico con la altura en el atributo x y el peso en el atributo y.\nggplot(df, aes(x = altura, y = peso)) +\n# Añadir la capa de puntos.\n    geom_point() +\n# Añadir un título al gráfico.\n    labs(title = \"Diagrama de dispersión\") +\n# Cambiar el tamaño y el color de la fuente del título.\n    theme(plot.title = element_text(size = 20, colour = \"blue\"))\n\n\n\n\n\n\n\n# Inicializar el gráfico con la altura en el atributo x, el peso en el atributo y, y el sexo al atributo colour.\nggplot(df, aes(x = altura, y = peso, colour = sexo)) +\n# Añadir la capa de puntos.\n    geom_point() +\n# Cambiar el la posición de la leyenda\n    theme(legend.position = \"top\")\n\n\n\n\n\nMás información sobre temas.\nggplot2 incorpora los siguientes temas predefinidos:\n- `theme_gray()`: Tema en escala de grises. Es el tema por defecto.\n- `theme_bw()`: Tema en blanco y negro.\n- `theme_light()`: Tema con las líneas de los ejes y de la rejilla delgadas y atenuadas para dar más protagonismo a los datos.\n- `theme_dark()`: Similar al tema anterior pero con fondo oscuro.\n- `theme_minimal()`: Tema sin fondo.\n- `theme_classic()`: Tema sin rejilla.\n- `theme_void()`: Tema vacío.\n\n\n# Inicializar el gráfico con la altura en el atributo x, el peso en el atributo y, y el sexo al atributo colour.\nggplot(df, aes(x = altura, y = peso, colour = sexo)) +\n# Añadir la capa de puntos.\n    geom_point() +\n# Usar el tema sin rejilla\n    theme_classic()"
  },
  {
    "objectID": "07-graficos.html#ejercicios",
    "href": "07-graficos.html#ejercicios",
    "title": "7  Gráficos y visualización de datos",
    "section": "7.13 Ejercicios",
    "text": "7.13 Ejercicios\n\nEl fichero neonatos contiene información sobre los recién nacidos en un hospital durante un año.\n\n\nCrear un tibble con los datos del fichero.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nlibrary(tidyverse)\ndf &lt;- read_csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/neonatos.csv')\ndf\n\n# A tibble: 320 × 8\n    peso sexo   edad        tabaco cigarros tabaco.antes apgar1 apgar5\n   &lt;dbl&gt; &lt;chr&gt;  &lt;chr&gt;       &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;         &lt;dbl&gt;  &lt;dbl&gt;\n 1  3.28 hombre mayor de 20 No            0 No                7      7\n 2  3.49 hombre mayor de 20 No            0 No                7      8\n 3  2.88 hombre mayor de 20 No            0 Si                5      6\n 4  3.42 hombre mayor de 20 No            0 No                8      8\n 5  3.31 hombre mayor de 20 No            0 No                6      7\n 6  3.53 hombre mayor de 20 No            0 No                8      8\n 7  3.46 hombre mayor de 20 No            0 No                7      8\n 8  3.12 hombre mayor de 20 No            0 No                7      7\n 9  2.77 hombre mayor de 20 No            0 No                5      5\n10  3.31 hombre mayor de 20 No            0 No                7      8\n# … with 310 more rows\n\n\n\n\n\n\nConvertir las variables sexo, edad, tabaco y tabaco.antes en factores.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ndf &lt;- mutate(df, sexo = factor(sexo), edad = factor(edad), tabaco = factor(tabaco), tabaco.antes = factor(tabaco.antes))\n\n\n\n\n\nDibujar un diagrama de barras con la frecuencia de niños y niñas.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nggplot(df, aes(x = sexo)) +\n    geom_bar()\n\n\n\n\n\n\n\n\nDibujar un diagrama de barras del apgar1 de los neonatos de madres fumadoras y no fumadoras durante el embarazo.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nggplot(df, aes(x = apgar1, fill = tabaco)) +\n    geom_bar(position = \"dodge\")\n\n\n\n\n\n\n\n\nDibujar un histograma acumulado del peso según el sexo con 10 clases.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nggplot(df, aes(x = peso, fill = sexo)) +\n    geom_histogram(bins = 10)\n\n\n\n\n\n\n\n\nDibujar un gráfico de densidad de probabilidad del peso de los neonatos de madres fumadoras y no fumadoras durante el embarazo.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nggplot(df, aes(x = peso, colour = tabaco)) +\n    geom_density()\n\n\n\n\n\n\n\n\nDibujar un diagrama de caja del peso de los recién nacidos según sexo y si la madre fumaba o no durante el embarazo.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nggplot(df, aes(x = sexo, y = peso, fill = tabaco)) +\n    geom_boxplot()\n\n\n\n\n\n\n\n\nDibujar un diagrama de dispersión del peso de los recién nacidos de madres fumadoras durante el embarazo, frente al número de cigarros que fumaban las madres. Incluir la recta de regresión.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ndf %&gt;% \n    filter(tabaco == \"Si\") %&gt;%\n    ggplot(aes(x = cigarros, y = peso)) +\n        geom_point() +\n        geom_smooth(method = \"lm\")\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\nDibujar un diagrama de dispersión del peso de los recién nacidos de madres fumadoras durante el embarazo, frente al número de cigarros que fumaban las madres, separando por facetas según el sexo y la edad de la madre.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ndf %&gt;% \n    filter(tabaco == \"Si\") %&gt;%\n    ggplot(aes(x = cigarros, y = peso)) +\n        geom_point() +\n        geom_smooth(method = \"lm\") +\n        facet_wrap(vars(sexo, edad))\n\n`geom_smooth()` using formula = 'y ~ x'"
  },
  {
    "objectID": "08-analisis-estadisticos.html#una-variable-cuantitativa",
    "href": "08-analisis-estadisticos.html#una-variable-cuantitativa",
    "title": "8  Análisis Estadísticos",
    "section": "8.1 Una variable cuantitativa",
    "text": "8.1 Una variable cuantitativa\n\n8.1.1 Estudios descriptivos\n\n8.1.1.1 Estadísticos\n\nTamaño muestral\nMedia\nDesviación típica\nMínimo, Máximo\nCuartiles\nCoeficiente de asimetría\nCoeficiente de apuntamiento\n\n\n# Tamaño muestral\nnrow(df)\n\n[1] 120\n\n\n\n# Media\nmean(df$notaA, na.rm = TRUE)\n\n[1] 6.028333\n\n\n\n# Desviación típica\nsd(df$notaA, na.rm = TRUE)\n\n[1] 1.340524\n\n\n\n# Min, max\nmin(df$notaA, na.rm = TRUE)\n\n[1] 2.5\n\n\n\nmax(df$notaA, na.rm = TRUE)\n\n[1] 9.3\n\n\n\n# Cuartiles\nquantile(df$notaA, c(0.25, 0.5, 0.75), na.rm = TRUE)\n\n  25%   50%   75% \n5.100 5.900 6.825 \n\n\n\n# Coef. asimetría\nlibrary(moments)\nskewness(df$notaA, na.rm = TRUE)\n\n[1] 0.1373915\n\n\n\n# Coef. apuntamiento\nkurtosis(df$notaA, na.rm = TRUE) - 3\n\n[1] -0.102287\n\n\n\n\n8.1.1.2 Gráficos\n\nDiagrama de barras (variables discretas)\n\n\ndf %&gt;% ggplot(aes(x = asinaturas.aprobadas)) + \n  geom_bar(fill=\"#00BFC4\") + \n  # Cambio de escala del eje X\n  scale_x_discrete(limits=0:5) \n\n\n\n\n\nHistograma\n\n\nlibrary(ggplot2)\n# Límites de los intervalos\nbreaks = 0:10\n# Histograma de las notasA\ndf %&gt;% ggplot(aes(x = notaA)) + \n  geom_histogram(breaks = breaks, fill=\"#00BFC4\") + \n  # Cambio de escala del eje X\n  scale_x_continuous(limits=c(0, 10), breaks = 0:10) \n\n\n\n\n\n# Histograma de notasE\ndf %&gt;% ggplot(aes(x = notaE)) + \n  geom_histogram(breaks = breaks, fill=\"#00BFC4\") + \n  # Cambio de escala del eje X\n  scale_x_continuous(limits=c(0, 10), breaks = 0:10) \n\n\n\n\n\nDiagrama de líneas\n\n\n# Variables discretas\ndf %&gt;% count(asinaturas.aprobadas) %&gt;%\n  ggplot(aes(x = asinaturas.aprobadas, y = n)) +\n  geom_line(col=\"#00BFC4\") + \n  # Cambio de escala del eje X\n  scale_x_discrete(limits=0:5) \n\n\n\n\n\n# Agrupación de datos en intervalos\ndf %&gt;% ggplot(aes(x = notaA)) + \n  geom_freqpoly(breaks = breaks, col=\"#00BFC4\") + \n  # Cambio de escala del eje X\n  scale_x_continuous(limits=c(0, 10), breaks = 0:10) \n\n\n\n\n\nDiagrama de caja y bigotes\n\n\ndf %&gt;% ggplot(aes(x = notaA)) + \n  geom_boxplot(fill=\"#00BFC4\") +\n  # Cambio de escala del eje X\n  scale_x_continuous(limits=c(0, 10), breaks = 0:10)\n\n\n\n\n\n\n\n8.1.2 Estudios inferenciales\n\n8.1.2.1 Test de normalidad de Shapiro-Wilk\nObjetivo: Comprobar la normalidad de la distribución.\nHipótesis nula: La distribución es normal.\n\nshapiro.test(df$notaA)\n\n\n    Shapiro-Wilk normality test\n\ndata:  df$notaA\nW = 0.99424, p-value = 0.907\n\n\n\nshapiro.test(df$notaE)\n\n\n    Shapiro-Wilk normality test\n\ndata:  df$notaE\nW = 0.92264, p-value = 4.065e-06\n\n\n\n\n8.1.2.2 Test t para la media de una población\nObjetivo: Estimar la media de una variable o compararla con un valor dado μ0.\nRequisitos:\n\nUna variable cuantitativa.\nDistribución normal o tamaño muestral ≥ 30.\n\nHipótesis nula: La media de la población es igual a μ0.\nEjemplo: Comprobar si la nota media de un examen es diferente de 5.\n\nt.test(df$notaA, mu = 5, alternative = \"two.sided\")\n\n\n    One Sample t-test\n\ndata:  df$notaA\nt = 8.4033, df = 119, p-value = 1.08e-13\nalternative hypothesis: true mean is not equal to 5\n95 percent confidence interval:\n 5.786023 6.270643\nsample estimates:\nmean of x \n 6.028333"
  },
  {
    "objectID": "08-analisis-estadisticos.html#una-variable-cualitativa",
    "href": "08-analisis-estadisticos.html#una-variable-cualitativa",
    "title": "8  Análisis Estadísticos",
    "section": "8.2 Una variable cualitativa",
    "text": "8.2 Una variable cualitativa\n\n8.2.1 Estudios descriptivos\n\n8.2.1.1 Estadísticos\n\nTamaños muestral\nFrecuencias muestrales\nProporciones/porcentajes muestrales\n\n\n# Tamaño muestral sin datos perdidos\nlength(na.omit(df$calificacionB))\n\n[1] 115\n\n\n\n# Frecuencias\ntable(df$calificacionB)\n\n\nAprobado Suspenso \n      98       17 \n\n\n\n# Proporciones\ntable(df$calificacionB) / length(na.omit(df$calificacionB))\n\n\n Aprobado  Suspenso \n0.8521739 0.1478261 \n\n\n\n# Porcentajes\ntable(df$calificacionB) / length(na.omit(df$calificacionB)) * 100\n\n\nAprobado Suspenso \n85.21739 14.78261 \n\n\n\n\n8.2.1.2 Gráficos\n\nDiagrama de sectores\n\n\ndf %&gt;% ggplot(aes(x = \"\", fill = calificacionA)) + \n  geom_bar() +\n  # Cambiar a coordenadas polares\n  coord_polar(theta = \"y\") +\n  # Eliminar ejes\n   theme_void()\n\n\n\n\n\n\n\n8.2.2 Estudios inferenciales\n\n8.2.2.1 Test binomial para una proporción de una población\nObjetivo: Estimar la propoción de una categoría en una población o compararla con un valor p0.\nRequisitos:\n\nOne variable cualitativa\n\nHipótesis nula: La proporción poblacional es igual a p0.\nEjemplo: Comprobar si la proporción de aprobados es mayor de 0.5.\n\nn &lt;- nrow(df)\nfreq &lt;- table(df$calificacionA)[\"Aprobado\"]\nbinom.test(freq, n, p = 0.5, alternative = \"greater\")\n\n\n    Exact binomial test\n\ndata:  freq and n\nnumber of successes = 94, number of trials = 120, p-value = 1.57e-10\nalternative hypothesis: true probability of success is greater than 0.5\n95 percent confidence interval:\n 0.7123183 1.0000000\nsample estimates:\nprobability of success \n             0.7833333 \n\n\n\n\n8.2.2.2 Test Z para la proporción de una población\nObjetivo: Estimar la propoción de una categoría en una población o compararla con un valor p0.\nRequisitos:\n\nUna variable cualitativa\nTamaño muestral &gt;= 30\n\nObservación: Utiliza la aproximación normal de la distribución Binomal.\nEjemplo: Comprobar si la proporción de aprobados es mayor de 0.5.\n\nfreq &lt;- table(df$calificacionA)[\"Aprobado\"]\nprop.test(freq, n, p = 0.7, alternative = \"greater\")\n\n\n    1-sample proportions test with continuity correction\n\ndata:  freq out of n, null probability 0.7\nX-squared = 3.5813, df = 1, p-value = 0.02922\nalternative hypothesis: true p is greater than 0.7\n95 percent confidence interval:\n 0.7111099 1.0000000\nsample estimates:\n        p \n0.7833333"
  },
  {
    "objectID": "08-analisis-estadisticos.html#dos-variables-variable-dependiente-cuantitativa-y-variable-independiente-culitativa-con-dos-categorías-o-grupos",
    "href": "08-analisis-estadisticos.html#dos-variables-variable-dependiente-cuantitativa-y-variable-independiente-culitativa-con-dos-categorías-o-grupos",
    "title": "8  Análisis Estadísticos",
    "section": "8.3 Dos variables: Variable dependiente cuantitativa y variable independiente culitativa con dos categorías o grupos",
    "text": "8.3 Dos variables: Variable dependiente cuantitativa y variable independiente culitativa con dos categorías o grupos\n\n8.3.1 Estudios descriptivos\n\n8.3.1.1 Estadísticos\n\nTamaño muestral de cada grupo\nMedia de cada grupo\nDesviación típica de cada grupo\nMínimo, Máximo de cada grupo\nCuartiles de cada grupo\nCoeficiente de asimetría de cada grupo\nCoeficiente de apuntamiento de cada grupo\n\n\n# Tamaño muestral de notaA según el sexo\ndf %&gt;% group_by(sexo) %&gt;% group_size()\n\n[1] 71 49\n\n\n\n# Media, Desviación típica, Mín, Máx, Cuartiles, Coef. Asimetría y Coef. Apuntamiento\nlibrary(moments)\ndf %&gt;% group_by(sexo) %&gt;% summarize(Media = mean(notaA, na.rm=TRUE), Des.Tip = sd(notaA, na.rm = TRUE), Mín = min(notaA), Máx = max(notaA), C1 = quantile(notaA, 0.25, na.rm = TRUE), C2 = quantile(notaA, 0.5, na.rm = TRUE), C3 = quantile(notaA, 0.75, na.rm = TRUE), Coef.Asimetría = skewness(notaA, na.rm = TRUE), Coef.Apuntamiento = kurtosis(notaA, na.rm = TRUE) - 3)\n\n# A tibble: 2 × 10\n  sexo   Media Des.Tip   Mín   Máx    C1    C2    C3 Coef.Asimetría Coef.Apunt…¹\n  &lt;chr&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;          &lt;dbl&gt;        &lt;dbl&gt;\n1 Hombre  6.12    1.23   3.5   9.3   5.3   6.1  6.85          0.249       -0.170\n2 Mujer   5.89    1.49   2.5   9.3   5     5.7  6.8           0.135       -0.240\n# … with abbreviated variable name ¹​Coef.Apuntamiento\n\n\n\n\n8.3.1.2 Gráficos\n\nDiagrama de cajas y bigotes\n\n\ndf %&gt;% ggplot(aes(x = sexo, y = notaA, fill = sexo)) + \n  geom_boxplot() +\n  # Cambio de escala del eje y\n  scale_y_continuous(limits=c(0, 10), breaks = 0:10)\n\n\n\n\n\nDiagrama de violín\n\n\ndf %&gt;% ggplot(aes(x = sexo, y = notaA, fill = sexo)) + \n  geom_violin() +\n  # Cambio de escala del eje y\n  scale_y_continuous(limits=c(0, 10), breaks = 0:10)\n\n\n\n\n\n\n\n8.3.2 Estudios inferenciales\n\n8.3.2.1 Test de normalidad de Shapiro-Wilks\nObjetivo: Comprobar la normalidad de la distribución de cada población.\nHipótesis nula: La distribución es normal.\n\ndf %&gt;% group_by(sexo) %&gt;% \n  summarise(`Estadístico W` = shapiro.test(notaA)$statistic, `p-valor` = shapiro.test(notaA)$p.value)\n\n# A tibble: 2 × 3\n  sexo   `Estadístico W` `p-valor`\n  &lt;chr&gt;            &lt;dbl&gt;     &lt;dbl&gt;\n1 Hombre           0.990     0.872\n2 Mujer            0.990     0.942\n\n\n\n\n8.3.2.2 Test F de Fisher de comparación de varianzas de dos poblaciones independientes\nObjetivo: Comparar las varianzas de dos poblaciones independientes.\nRequisitos:\n\nVariable dependiente cuantitativa.\nUna variable independiente cualitativa con dos categorías (poblaciones)\nDistribución normal de la variable dependiente en ambas poblaciones o tamaños de las muestras de cada población ≥ 30.\n\nHipótesis nula: La varianzas poblacionales son iguales (no existe una diferencia significativa entre las medias poblacionales).\nEjemplo: Comprobar si diferencias signicativas entre las notas medias de hombres y mujeres.\n\n# Test de comparación de varianzas\nvar.test(notaA ~ sexo, data = df)\n\n\n    F test to compare two variances\n\ndata:  notaA by sexo\nF = 0.6769, num df = 70, denom df = 48, p-value = 0.1347\nalternative hypothesis: true ratio of variances is not equal to 1\n95 percent confidence interval:\n 0.3953421 1.1293155\nsample estimates:\nratio of variances \n         0.6769032 \n\n\n\n\n8.3.2.3 Test t de comparación de medias de dos poblaciones independientes\nObjetivo: Estimar la diferencia de medias en las dos poblaciones o comprobar si hay diferencias significativas entre ellas.\nRequisitos:\n\nVariable dependiente cuantitativa.\nUna variable independiente cualitativa con dos categorías (poblaciones)\nDistribución normal de la variable dependiente en ambas poblaciones o tamaños de las muestras de cada población ≥ 30.\n\nHipótesis nula: La medias poblacionales son iguales (no existe una diferencia significativa entre las medias poblacionales).\nObservación: El resultado del test depende de si las varianzas poblacionales son iguales o no.\nEjemplo: Comprobar si diferencias signicativas entre las notas medias de hombres y mujeres.\n\n# Test de comparación de varianzas\nvar.test(notaA ~ sexo, data = df)\n\n\n    F test to compare two variances\n\ndata:  notaA by sexo\nF = 0.6769, num df = 70, denom df = 48, p-value = 0.1347\nalternative hypothesis: true ratio of variances is not equal to 1\n95 percent confidence interval:\n 0.3953421 1.1293155\nsample estimates:\nratio of variances \n         0.6769032 \n\n\n\n# Test de comparación de medias asumiendo varianzas iguales\nt.test (notaA ~ sexo, data = df, alternative = \"two.sided\", var.equal = FALSE)\n\n\n    Welch Two Sample t-test\n\ndata:  notaA by sexo\nt = 0.89364, df = 89.873, p-value = 0.3739\nalternative hypothesis: true difference in means between group Hombre and group Mujer is not equal to 0\n95 percent confidence interval:\n -0.2821809  0.7435779\nsample estimates:\nmean in group Hombre  mean in group Mujer \n            6.122535             5.891837 \n\n\n\n# Test de comparación de medias asumiendo varianzas iguales\nt.test (notaA ~ sexo, data = df, alternative = \"two.sided\", var.equal = TRUE)\n\n\n    Two Sample t-test\n\ndata:  notaA by sexo\nt = 0.92608, df = 118, p-value = 0.3563\nalternative hypothesis: true difference in means between group Hombre and group Mujer is not equal to 0\n95 percent confidence interval:\n -0.262615  0.724012\nsample estimates:\nmean in group Hombre  mean in group Mujer \n            6.122535             5.891837 \n\n\n\nDiagrama de medias\n\n\ndf %&gt;% ggplot(aes(x = sexo, y = notaA, colour = sexo)) + \n  # Puntos de medias\n  stat_summary(fun=\"mean\", size=3,  geom=\"point\", position=position_dodge(width=0.25)) + \n  # Intervalos de confianza para la media\n  stat_summary(fun.data = function(x) mean_cl_normal(x, conf.int=0.95), geom = \"pointrange\", position=position_dodge(width=0.25)) \n\n\n\n\n\n\n8.3.2.4 Test U de Mann-Whitney de comparación de dos poblaciones independientes (no paramétrico)\nObjetivo: Comprobar si hay diferencias significativas entre entre dos poblaciones independientes.\nRequisitos:\n\nVariable dependiente cuantitativa.\nUna variable independiente cualitativa con dos categorías (poblaciones)\n\nHipótesis nula: La medianas poblacionales son iguales (no existe una diferencia significativa entre las medianas poblacionales).\nEjemplo: Comprobar si diferencias signicativas entre las notas de hombres y mujeres.\n\n# Test de rangos U the Mann-Whitney\nwilcox.test(notaA ~ sexo, data = df, alternative = \"two.sided\")\n\n\n    Wilcoxon rank sum test with continuity correction\n\ndata:  notaA by sexo\nW = 1917, p-value = 0.3445\nalternative hypothesis: true location shift is not equal to 0"
  },
  {
    "objectID": "08-analisis-estadisticos.html#dos-variables-variable-dependiente-cuantitativa-y-variable-independiente-culitativa-con-dos-categorías-o-grupos-pareados",
    "href": "08-analisis-estadisticos.html#dos-variables-variable-dependiente-cuantitativa-y-variable-independiente-culitativa-con-dos-categorías-o-grupos-pareados",
    "title": "8  Análisis Estadísticos",
    "section": "8.4 Dos variables: Variable dependiente cuantitativa y variable independiente culitativa con dos categorías o grupos pareados",
    "text": "8.4 Dos variables: Variable dependiente cuantitativa y variable independiente culitativa con dos categorías o grupos pareados\nDos grupos o poblaciones están pareadas o emparejadas cuando los dos poblaciones contienen los mismos individuos, es decir, se trata en realidadad de una única población, pero la variable dependiente se mide dos veces en cada individuo (normalmente antes y después de la algún suceso) y por tanto cada individuo tiene asociado un par de valores.\nEste estudio puede realizarse también creando una nueva variable a partir de la resta de las dos mediciones y planteando un estudio de una sola variable cuantitativa.\nEjemplo: Creación de la diferencia de notas de las asignaturas A y B.\n\n# Creamos la variable diferencia = notaA - notaB\ndf &lt;- df %&gt;% mutate(diferencia = notaA - notaB)\n\n\n8.4.1 Estudios descriptivos\n\n8.4.1.1 Estadísticos\n\nTamaño muestral del grupo\nMedia de la diferencia\nDesviación típica de la diferencia\nMínimo, Máximo de la diferencia\nCuartiles de la diferencia\nCoeficiente de asimetría de la diferencia\nCoeficiente de apuntamiento de la diferencia\n\nEjemplo: Estadísticos descriptivos de la diferencia entre las notas de las asignaturas A y B de un mismo grupo de alumnos.\n\n# Tamaño muestral de sin contar los datos perdidos\nlength(na.omit(df$diferencia))\n\n[1] 115\n\n\n\n# Media, Desviación típica, Mín, Máx, Cuartiles, Coef. Asimetría y Coef. Apuntamiento\nlibrary(moments)\ndf %&gt;% summarize(Media = mean(diferencia, na.rm=TRUE), Des.Tip = sd(diferencia, na.rm = TRUE), Mín = min(diferencia, na.rm = TRUE), Máx = max(diferencia, na.rm = TRUE), C1 = quantile(diferencia, 0.25, na.rm = TRUE), C2 = quantile(diferencia, 0.5, na.rm = TRUE), C3 = quantile(diferencia, 0.75, na.rm = TRUE), Coef.Asimetría = skewness(diferencia, na.rm = TRUE), Coef.Apuntamiento = kurtosis(diferencia, na.rm = TRUE) - 3)\n\n       Media   Des.Tip  Mín Máx   C1   C2   C3 Coef.Asimetría Coef.Apuntamiento\n1 -0.8817391 0.9000568 -3.2 1.1 -1.5 -0.8 -0.3     -0.4304152        -0.1366944\n\n\n\n\n8.4.1.2 Gráficos\n\nDiagrama de cajas y bigotes\n\n\ndf %&gt;% ggplot(aes(x = diferencia)) + \n  geom_boxplot(fill=\"#00BFC4\")\n\n\n\n\n\n\n\n8.4.2 Estudios inferenciales\n\n8.4.2.1 Test de normalidad de Shapiro-Wilks\nObjetivo: Comprobar la normalidad de la distribución de la diferencia.\nHipótesis nula: La distribución es normal.\nEjemplo: Comprobar la normalidad de la diferencia entre las notas de las asignaturas A y B de un mismo grupo de alumnos.\n\ndf %&gt;% summarise(`Estadístico W` = shapiro.test(diferencia)$statistic, `p-valor` = shapiro.test(diferencia)$p.value)\n\n  Estadístico W    p-valor\n1     0.9794023 0.07367451\n\n\n\n\n8.4.2.2 Test t de comparación de medias de dos poblaciones pareadas\nObjetivo: Estimar la media de la diferencia o compararla con un valor dado μ0.\nRequisitos:\n\nVariable dependiente cuantitativa.\nUna variable independiente cualitativa con dos categorías (poblaciones) pareadas\nDistribución normal de la variable diferencia o tamaño muestral ≥ 30.\n\nHipótesis nula: La medias poblacionales son iguales (no existe una diferencia significativa entre las medias poblacionales).\nEjemplo: Comprobar si hay una diferencia signicativa entre las notas medias de las asinaturas A y B, o lo que es lo mismo, comprobar si la media de la diferencia de las notas de A y B es distinta de 0.\n\nt.test (df$notaA, df$notaB, alternative = \"two.sided\", paired = TRUE)\n\n\n    Paired t-test\n\ndata:  df$notaA and df$notaB\nt = -10.506, df = 114, p-value &lt; 2.2e-16\nalternative hypothesis: true mean difference is not equal to 0\n95 percent confidence interval:\n -1.048005 -0.715473\nsample estimates:\nmean difference \n     -0.8817391 \n\n\n\nDiagrama de medias\n\n\ndf %&gt;% ggplot(aes(x=\"\", y = diferencia)) + \n  # Puntos de medias\n  stat_summary(fun=\"mean\", size=3,  geom=\"point\") + \n  # Intervalos de confianza para la media\n  stat_summary(fun.data = function(x) mean_cl_normal(x, conf.int=0.95), geom = \"pointrange\", position=position_dodge(width=0.25)) \n\n\n\n\n\n\n8.4.2.3 Test Wilcoxon de comparación de dos poblaciones pareadas (no paramétrico)\nObjetivo: Comparar las medianas de las dos poblaciones.\nRequisitos:\n\nVariable dependiente cuantitativa.\nUna variable independiente cualitativa con dos categorías (poblaciones) pareadas.\n\nHipótesis nula: La medianas poblacionales son iguales (no existe una diferencia significativa entre las medianas poblacionales).\nEjemplo: Comprobar si hay una diferencia signicativa entre las notas de las asignaturas A y B.\n\nwilcox.test(df$notaA, df$notaB, alternative = \"two.sided\", paired = TRUE)\n\n\n    Wilcoxon signed rank test with continuity correction\n\ndata:  df$notaA and df$notaB\nV = 398, p-value = 2.442e-15\nalternative hypothesis: true location shift is not equal to 0"
  },
  {
    "objectID": "08-analisis-estadisticos.html#dos-variables-variable-dependiente-cuantitativa-y-variable-independiente-culitativa-con-más-de-dos-categorías-o-grupos",
    "href": "08-analisis-estadisticos.html#dos-variables-variable-dependiente-cuantitativa-y-variable-independiente-culitativa-con-más-de-dos-categorías-o-grupos",
    "title": "8  Análisis Estadísticos",
    "section": "8.5 Dos variables: Variable dependiente cuantitativa y variable independiente culitativa con más de dos categorías o grupos",
    "text": "8.5 Dos variables: Variable dependiente cuantitativa y variable independiente culitativa con más de dos categorías o grupos\n\n8.5.1 Estudios descriptivos\n\n8.5.1.1 Estadísticos\n\nTamaño muestral de cada grupo\nMedia de cada grupo\nDesviación típica de cada grupo\nMínimo, Máximo de cada grupo\nCuartiles de cada grupo\nCoeficiente de asimetría de cada grupo\nCoeficiente de apuntamiento de cada grupo\n\n\n# Tamaño muestral de notaA según el grupo\ndf %&gt;% group_by(grupo) %&gt;% group_size()\n\n[1] 38 35 47\n\n\n\n# Media, Desviación típica, Mín, Máx, Cuartiles, Coef. Asimetría y Coef. Apuntamiento\nlibrary(moments)\ndf %&gt;% group_by(grupo) %&gt;% summarize(Media = mean(notaA, na.rm=TRUE), Des.Tip = sd(notaA, na.rm = TRUE), Mín = min(notaA, na.rm = TRUE), Máx = max(notaA, na.rm = TRUE), C1 = quantile(notaA, 0.25, na.rm = TRUE), C2 = quantile(notaA, 0.5, na.rm = TRUE), C3 = quantile(notaA, 0.75, na.rm = TRUE), Coef.Asimetría = skewness(notaA, na.rm = TRUE), Coef.Apuntamiento = kurtosis(notaA, na.rm = TRUE) - 3)\n\n# A tibble: 3 × 10\n  grupo Media Des.Tip   Mín   Máx    C1    C2    C3 Coef.Asimetría Coef.Apunta…¹\n  &lt;chr&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;          &lt;dbl&gt;         &lt;dbl&gt;\n1 A      6.54   0.998   4.3   8.6  5.93   6.6  7.15         -0.250        -0.166\n2 B      6.96   1.23    3.5   9.3  6.2    6.8  7.7          -0.141         0.522\n3 C      4.92   0.771   2.5   5.9  4.5    5.1  5.5          -1.06          0.902\n# … with abbreviated variable name ¹​Coef.Apuntamiento\n\n\n\n\n8.5.1.2 Gráficos\n\nDiagrama de cajas y bigotes\n\n\ndf %&gt;% ggplot(aes(x = grupo, y = notaA, fill = grupo)) + \n  geom_boxplot() +\n  # Cambio de escala del eje X\n  scale_y_continuous(limits=c(0, 10), breaks = 0:10)\n\n\n\n\n\nDiagrama de violín\n\n\ndf %&gt;% ggplot(aes(x = grupo, y = notaA, fill = grupo)) + \n  geom_violin() +\n  # Cambio de escala del eje X\n  scale_y_continuous(limits=c(0, 10), breaks = 0:10)\n\n\n\n\n\n\n\n8.5.2 Estudios inferenciales\n\n8.5.2.1 Test de normalidad de Shapiro-Wilks\nObjetivo: Comprobar la normalidad de la distribución de cada población.\nHipótesis nula: La distribución es normal.\nEjemplo: Comprobar la normalidad de las distribuciones de la nota A en los grupos A, B y C.\n\ndf %&gt;% group_by(grupo) %&gt;% \n  summarise(`Estadístico W` = shapiro.test(notaA)$statistic, `p-valor` = shapiro.test(notaA)$p.value)\n\n# A tibble: 3 × 3\n  grupo `Estadístico W` `p-valor`\n  &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n1 A               0.984   0.840  \n2 B               0.963   0.277  \n3 C               0.918   0.00280\n\n\nInterpretación: La distribución de la nota A en los grupos A y B es normal (p-valores &gt; 0.05) pero no en el grupo C (p-valor &lt; 0.05)\nEjemplo: Comprobar la normalidad de las distribuciones de la nota C en los grupos A, B y C.\n\ndf %&gt;% group_by(grupo) %&gt;% \n  summarise(`Estadístico W` = shapiro.test(notaC)$statistic, `p-valor` = shapiro.test(notaC)$p.value)\n\n# A tibble: 3 × 3\n  grupo `Estadístico W` `p-valor`\n  &lt;chr&gt;           &lt;dbl&gt;     &lt;dbl&gt;\n1 A               0.989     0.961\n2 B               0.965     0.343\n3 C               0.976     0.442\n\n\nInterpretación: La distribución de la nota C en los tres grupos es normal (p-valores &gt; 0.05).\n\n\n8.5.2.2 Test de Levene de comparación de varianzas de dos o más poblaciones independientes\nObjetivo: Comparar las varianzas de dos o más poblaciones independientes.\nRequisitos:\n\nVariable dependiente cuantitativa.\nUna variable independiente cualitativa con dos o más categorías (poblaciones)\nDistribución normal de la variable dependiente en todas las poblaciones o tamaños de las muestras de cada población ≥ 30.\n\nHipótesis nula: La varianzas poblacionales son iguales (no existe una diferencia significativa entre las medias poblacionales).\nEjemplo: Comprobar si diferencias signicativas entre las varianzas de las notas de la asignatura C de los grupos A, B y C.\n\n# El test de Levene está disponible en el paquete car\nlibrary(car)\n# Test de comparación de varianzas\nleveneTest(notaC ~ grupo, data = df)\n\nLevene's Test for Homogeneity of Variance (center = median)\n       Df F value Pr(&gt;F)\ngroup   2  0.3186 0.7278\n      116               \n\n\nInterpretación: No existe diferencia significativa entre las varianzas de la nota C en los grupos A, B y C (p-valor &gt; 0.05).\n\n\n8.5.2.3 ANOVA de un factor para la comparación medias de más de dos poblaciones independientes\nObjetivo: Comprobar si hay diferencias significativas entre las medias de más de dos poblaciones independientes.\nRequisitos:\n\nVariable dependiente cuantitativa.\nUna variable independiente cualitativa con más de dos categorías (poblaciones)-\nDistribución normal de la variable dependiente en todas las poblaciones o tamaños de las muestras de cada población ≥ 30.\nHomogeneidad de varianzas en las poblaciones.\n\nHipótesis nula: La medias poblacionales son iguales (no existe una diferencia significativa entre las medias poblacionales).\nEjemplo: Comprobar si diferencias signicativas entre las notas medias de la asignatura C de los grupos A, B y C.\n\n# Análisis de la varianza de un factor\nsummary(aov(notaC ~ grupo, data = df))\n\n             Df Sum Sq Mean Sq F value   Pr(&gt;F)    \ngrupo         2  80.69   40.34   20.05 3.32e-08 ***\nResiduals   116 233.41    2.01                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n1 observation deleted due to missingness\n\n\nInterpretación: Existen diferencias significativas entre las medias de la nota C entre al menos dos grupos (p-valor=3.32e-08 &lt; 0.05).\nObservación: Cuando se detectan diferencias significativas entre las medias de al menos dos grupos conviene realizar un test de comparación múltiple por pares para ver entre qué poblaciones hay diferencias y entre cuáles no. Los test más habituales de comparación por pares son el de Tukey y el de Bonferroni.\n\n# Test de comparación múltiple de Tukey\nTukeyHSD(aov(notaC ~ grupo, data = df))\n\n  Tukey multiple comparisons of means\n    95% family-wise confidence level\n\nFit: aov(formula = notaC ~ grupo, data = df)\n\n$grupo\n          diff        lwr        upr     p adj\nB-A  0.4312693 -0.3637573  1.2262960 0.4048482\nC-A -1.4455767 -2.1802858 -0.7108676 0.0000241\nC-B -1.8768461 -2.6350758 -1.1186163 0.0000001\n\n\nInterpretación: No existe una diferencia significativa entre las notas medias de la asignatura C de los grupos A y B (p-valor=0.4048 &gt; 0.05), pero si existe una diferencia significativa entre las notas medias de los grupos A y C (p-valor=0.00002 &lt; 0.05) y también entre las notas medias de los grupos B y C (p-valor=0.0000001 &lt; 0.05).\n\nDiagrama de medias\n\n\ndf %&gt;% ggplot(aes(x = grupo, y = notaC, colour = grupo)) + \n  # Puntos de medias\n  stat_summary(fun=\"mean\", size=3,  geom=\"point\", position=position_dodge(width=0.25)) + \n  # Intervalos de confianza para la media\n  stat_summary(fun.data = function(x) mean_cl_normal(x, conf.int=0.95), geom = \"pointrange\", position=position_dodge(width=0.25)) \n\n\n\n\n\n\n8.5.2.4 Test Kruskal-Wallis de comparación de más de dos poblaciones independientes (no paramétrico)\nObjetivo: Comprobar si hay diferencias significativas entre entre más de dos poblaciones independientes.\nRequisitos:\n\nVariable dependiente cuantitativa.\nUna variable independiente cualitativa con más de dos categorías (poblaciones)\n\nHipótesis nula: La medianas poblacionales son iguales (no existe una diferencia significativa entre las medianas poblacionales).\nEjemplo: Comprobar si diferencias signicativas entre las notas de la asignatura A de los grupos A, B y C.\n\n# Test de Kruskal-Wallis\nkruskal.test(notaA ~ grupo, data = df)\n\n\n    Kruskal-Wallis rank sum test\n\ndata:  notaA by grupo\nKruskal-Wallis chi-squared = 62.218, df = 2, p-value = 3.087e-14\n\n\nInterpretación: Existen diferencias significativas entre las notas de la asignatura A de al menos dos de los grupos.\nObservación: Cuando se detectan diferencias significativas entre al menos dos grupos conviene realizar un test de comparación múltiple por pares para ver entre qué poblaciones hay diferencias y entre cuáles no. El test más habitual es el de Wilcoxon.\n\n# Test de comparación múltiple de Wilcoxon\npairwise.wilcox.test(df$notaA, df$grupo, p.adjust.method = \"BH\")\n\n\n    Pairwise comparisons using Wilcoxon rank sum test with continuity correction \n\ndata:  df$notaA and df$grupo \n\n  A       B      \nB 0.19    -      \nC 4.2e-10 1.3e-11\n\nP value adjustment method: BH \n\n\nInterpretación: No existe una diferencia significativa entre las notas de la asignatura A de los grupos A y B (p-valor=0.19 &gt; 0.05), pero si existe una diferencia significativa entre las notas de los grupos A y C (p-valor=4.2e-10 &lt; 0.05) y también entre las notas de los grupos B y C (p-valor=1.3e-11 &lt; 0.05)."
  },
  {
    "objectID": "08-analisis-estadisticos.html#dos-variables-variable-dependiente-cuantitativa-y-variable-independiente-cuantitativa",
    "href": "08-analisis-estadisticos.html#dos-variables-variable-dependiente-cuantitativa-y-variable-independiente-cuantitativa",
    "title": "8  Análisis Estadísticos",
    "section": "8.6 Dos variables: Variable dependiente cuantitativa y variable independiente cuantitativa",
    "text": "8.6 Dos variables: Variable dependiente cuantitativa y variable independiente cuantitativa\n\n8.6.1 Estudios descriptivos\n\n8.6.1.1 Estadísticos\n\n\n8.6.1.2 Estadísticos\n\nTamaño muestral de cada grupo\nMedia de cada variable\nDesviación típica de cada variable\nMínimo, Máximo de cada variable\nCuartiles de cada variable\nCoeficiente de asimetría de cada variable\nCoeficiente de apuntamiento de cada variable\n\n\n# Tamaño muestral de notaA según el grupo\nnrow(df)\n\n[1] 120\n\n\n\n# Media, Desviación típica, Mín, Máx, Cuartiles, Coef. Asimetría y Coef. Apuntamiento\nlibrary(moments)\ndf %&gt;% summarize(Media = mean(notaA, na.rm=TRUE), Des.Tip = sd(notaA, na.rm = TRUE), Mín = min(notaA, na.rm = TRUE), Máx = max(notaA, na.rm = TRUE), C1 = quantile(notaA, 0.25, na.rm = TRUE), C2 = quantile(notaA, 0.5, na.rm = TRUE), C3 = quantile(notaA, 0.75, na.rm = TRUE), Coef.Asimetría = skewness(notaA, na.rm = TRUE), Coef.Apuntamiento = kurtosis(notaA, na.rm = TRUE) - 3)\n\n     Media  Des.Tip Mín Máx  C1  C2    C3 Coef.Asimetría Coef.Apuntamiento\n1 6.028333 1.340524 2.5 9.3 5.1 5.9 6.825      0.1373915         -0.102287\n\n\n\n\n8.6.1.3 Gráficos\n\nDiagrama de dispersión\n\n\ndf %&gt;% ggplot(aes(x = notaA, y = notaB)) + \n  geom_point()\n\n\n\n\n\n\n\n8.6.2 Estudios inferenciales\n\n8.6.2.1 Análisis de regresión\nObjetivo: Construir un modelo matemático \\(y=f(x)\\) que explique lo mejor posible la variable dependiente en función de la independiente, para utilizarlo con fines predictivos.\nRequisitos:\n\nVariable dependiente cuantitativa.\nUna variable independiente cuantitativa.\n\nEjemplo: Construir el modelo lineal (recta de regresión) que mejor explica la relación entre la nota B y la nota A.\n\n# Análisis de la varianza de un factor\nlm(notaB ~ notaA, data = df)\n\n\nCall:\nlm(formula = notaB ~ notaA, data = df)\n\nCoefficients:\n(Intercept)        notaA  \n     1.0224       0.9763  \n\n\n\n# Análisis de la varianza de un factor\nsummary(lm(notaB ~ notaA, data = df))\n\n\nCall:\nlm(formula = notaB ~ notaA, data = df)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-1.99907 -0.59551 -0.07534  0.61398  2.31991 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  1.02243    0.40254    2.54   0.0124 *  \nnotaA        0.97628    0.06637   14.71   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.9035 on 113 degrees of freedom\n  (5 observations deleted due to missingness)\nMultiple R-squared:  0.6569,    Adjusted R-squared:  0.6539 \nF-statistic: 216.3 on 1 and 113 DF,  p-value: &lt; 2.2e-16\n\n\nInterpretación: La recta de regresión explica el 65% de la variabilidad de la nota B.\n\n\n8.6.2.2 Análisis de correlación\nObjetivo: Estudiar el grado de relación entre las dos variables.\nRequisitos:\n\nVariable dependiente cuantitativa.\nUna variable independiente cuantitativa.\n\nHipótesis nula: Las dos variables son independientes.\nEjemplo: Ver si las notas A y B están relacionadas y cuál es su grado de relación.\n\n# Análisis de la varianza de un factor\ncor.test(df$notaA, df$notaB)\n\n\n    Pearson's product-moment correlation\n\ndata:  df$notaA and df$notaB\nt = 14.709, df = 113, p-value &lt; 2.2e-16\nalternative hypothesis: true correlation is not equal to 0\n95 percent confidence interval:\n 0.7367182 0.8651991\nsample estimates:\n      cor \n0.8104926 \n\n\nInterpretación: Existe una correlación fuerte entre la nota A y la nota C, que además es estadísticamente muy significativa."
  },
  {
    "objectID": "08-analisis-estadisticos.html#ejercicios",
    "href": "08-analisis-estadisticos.html#ejercicios",
    "title": "8  Análisis Estadísticos",
    "section": "8.7 Ejercicios",
    "text": "8.7 Ejercicios\n\nEl fichero genetica, contiene información de la análitica fisiológica, microbiológica y bioquímica, de una muestra de ratas tratadas con distintos tratamientos.\n\n\nCrear un tibble con los datos del fichero.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\nlibrary(tidyverse)\ndf &lt;- read_csv('https://raw.githubusercontent.com/asalber/manual-r/master/datos/genetica.csv')\ndf\n\n# A tibble: 21 × 20\n   códig…¹ Trata…² mas c…³    IHS     IES     ITS    IAS gluco…⁴ pbmc(…⁵ CD4(c…⁶\n   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n 1 Ct-A1   Control    236  0.0433 0.00198 0.00178 4.3e-4    54.1  7.01e3   401. \n 2 Ct-A2   Control    202. 0.044  0.002   0.0017  8  e-4    50.7  2.42e6   553. \n 3 Ct-B1   Control    246. 0.042  0.002   0.0015  5  e-4    72.2  6.19e6   724. \n 4 Ct-B2   Control    237. 0.0475 0.00238 0.00203 4.1e-4    95.3  1.79e6  2213. \n 5 Ct-B3   Control    231. 0.0499 0.002   0.0011  5  e-4    93.1  5.82e7  4518. \n 6 Ct-C1   Control    235. 0.05   0.0021  0.0033  1.4e-3    22.6  3.39e7   775. \n 7 Ct-C2   Control    228. 0.05   0.0018  0.0031  5.9e-4    29.4  7.5 e3    83.4\n 8 Dx-1    Dexame…    181. 0.061  0.00155 0.0005  1.2e-4    56.0  7.68e2    10  \n 9 Dx-2    Dexame…    198. 0.063  0.00191 0.0011  2  e-4   119.   1.41e6    15  \n10 Dx-3    Dexame…    201. 0.0577 0.0017  0.0001  1  e-4   119.   7.12e3    11  \n# … with 11 more rows, 10 more variables: `monoc(cel/mL)` &lt;dbl&gt;,\n#   `IHQ: linfB(cel/mm2)` &lt;dbl&gt;, `pulp.blan(Tx1)` &lt;dbl&gt;,\n#   `microorg(log nº/g)` &lt;dbl&gt;, `AI2(absorb)` &lt;dbl&gt;, `gluc(mmol/L)` &lt;dbl&gt;,\n#   `TAG(mmol/L)` &lt;dbl&gt;, `col(mmol/L)` &lt;dbl&gt;, `HDL(mmol/L)` &lt;dbl&gt;,\n#   `ins(pmol/L)` &lt;dbl&gt;, and abbreviated variable names ¹​`código muestra`,\n#   ²​Tratamiento, ³​`mas cor (g)`, ⁴​`glucog(mg/g)`, ⁵​`pbmc(cel/mL)`,\n#   ⁶​`CD4(cel/µL)`\n\n\n\n\n\n\nConvertir el tratamiento en un factor.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ndf &lt;- mutate(df, Tratamiento = factor(Tratamiento))\n\n\n\n\n\nCalcular el tamaño muestral de cada grupo de tratamiento\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ncount(df, Tratamiento)\n\n# A tibble: 3 × 2\n  Tratamiento      n\n  &lt;fct&gt;        &lt;int&gt;\n1 Control          7\n2 Dexametasona     7\n3 Kanamicina       7\n\n\n\n\n\n\nComprobar la normalidad de la variable IHS en cada grupo de tratamiento.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\ndf %&gt;% group_by(Tratamiento) %&gt;% \n  summarise(`Estadístico W` = shapiro.test(IHS)$statistic, `p-valor` = shapiro.test(IHS)$p.value)\n\n# A tibble: 3 × 3\n  Tratamiento  `Estadístico W` `p-valor`\n  &lt;fct&gt;                  &lt;dbl&gt;     &lt;dbl&gt;\n1 Control                0.837    0.0928\n2 Dexametasona           0.976    0.939 \n3 Kanamicina             0.908    0.383 \n\n\n\n\n\n\nComprobar la homocedasticiad de varianzas de la variable IHS en los tres grupos de tratamiento.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\n# El test de Levene está disponible en el paquete car\nlibrary(car)\n# Test de comparación de varianzas\nleveneTest(IHS ~ Tratamiento, data = df)\n\nLevene's Test for Homogeneity of Variance (center = median)\n      Df F value Pr(&gt;F)\ngroup  2  0.1636 0.8503\n      18               \n\n\n\n\n\n\nRealizar un contraste de ANOVA para comparar las medias de la variable IHS entre los tres grupos de tratamiento.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\n# Análisis de la varianza de un factor\nsummary(aov(IHS ~ Tratamiento, data = df))\n\n            Df    Sum Sq  Mean Sq F value   Pr(&gt;F)    \nTratamiento  2 0.0007900 3.95e-04   31.78 1.24e-06 ***\nResiduals   18 0.0002237 1.24e-05                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\n\n\nRealizar los contrastes de comparación de medias de la variable IHS por pares de trataimentos.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\n# Test de comparación múltiple de Tukey\nTukeyHSD(aov(IHS ~ Tratamiento, data = df))\n\n  Tukey multiple comparisons of means\n    95% family-wise confidence level\n\nFit: aov(formula = IHS ~ Tratamiento, data = df)\n\n$Tratamiento\n                                 diff          lwr          upr     p adj\nDexametasona-Control     0.0133857143  0.008576441  0.018194988 0.0000037\nKanamicina-Control       0.0007857143 -0.004023559  0.005594988 0.9090945\nKanamicina-Dexametasona -0.0126000000 -0.017409273 -0.007790727 0.0000082\n\n\n\n\n\n\nRealizar un contraste de Kruskal-Wallis para ver si hay diferencias significativas en la variable IHS entre los tres grupos de tratamiento.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\n# Test de Kruskal-Wallis\nkruskal.test(IHS ~ Tratamiento, data = df)\n\n\n    Kruskal-Wallis rank sum test\n\ndata:  IHS by Tratamiento\nKruskal-Wallis chi-squared = 13.433, df = 2, p-value = 0.001211\n\n\n\n\n\n\nConstruir la recta de regresión del variable IHS sobre la variable IES.\n\n\n\n\n\n\n\nSolución\n\n\n\n\n\n\n# Test de Kruskal-Wallis\nlm(IHS ~ IES, data = df)\n\n\nCall:\nlm(formula = IHS ~ IES, data = df)\n\nCoefficients:\n(Intercept)          IES  \n    0.08266    -15.97510  \n\nsummary(lm(IHS ~ IES, data = df))\n\n\nCall:\nlm(formula = IHS ~ IES, data = df)\n\nResiduals:\n       Min         1Q     Median         3Q        Max \n-0.0099081 -0.0040654  0.0006222  0.0031102  0.0142492 \n\nCoefficients:\n             Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   0.08266    0.01470   5.625 2.01e-05 ***\nIES         -15.97510    7.47347  -2.138   0.0458 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.006558 on 19 degrees of freedom\nMultiple R-squared:  0.1939,    Adjusted R-squared:  0.1514 \nF-statistic: 4.569 on 1 and 19 DF,  p-value: 0.04577"
  }
]